"use strict";(self.webpackChunkkumo_website=self.webpackChunkkumo_website||[]).push([[53876],{17608:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>d,toc:()=>a});var s=i(74848),r=i(28453);const o={title:"Getting started with versioning",description:"Learn how to use versioning in kmpkg",date:"01/10/2024",ROBOTS:"NOINDEX",is_archived:!0},t="Getting started with versioning",d={id:"kmpkg/users/examples/versioning.getting-started",title:"Getting started with versioning",description:"Learn how to use versioning in kmpkg",source:"@site/docs/kmpkg/users/examples/versioning.getting-started.md",sourceDirName:"kmpkg/users/examples",slug:"/kmpkg/users/examples/versioning.getting-started",permalink:"/docs/next/kmpkg/users/examples/versioning.getting-started",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Getting started with versioning",description:"Learn how to use versioning in kmpkg",date:"01/10/2024",ROBOTS:"NOINDEX",is_archived:!0}},l={},a=[{value:"Using versions with manifests",id:"using-versions-with-manifests",level:2},{value:"Manifest changes",id:"manifest-changes",level:3},{value:"<code>version</code>",id:"version",level:4},{value:"<code>version&gt;=</code>",id:"version-1",level:4},{value:"<code>builtin-baseline</code>",id:"builtin-baseline",level:4},{value:"<code>overrides</code>",id:"overrides",level:4},{value:"Versions and custom ports",id:"versions-and-custom-ports",level:2},{value:"Further reading",id:"further-reading",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"getting-started-with-versioning",children:"Getting started with versioning"})}),"\n",(0,s.jsx)(n.h2,{id:"using-versions-with-manifests",children:"Using versions with manifests"}),"\n",(0,s.jsxs)(n.p,{children:["Let's start with creating a simple CMake project that depends on ",(0,s.jsx)(n.code,{children:"fmt"})," and ",(0,s.jsx)(n.code,{children:"zlib"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Create a folder with the following files:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"kmpkg.json"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\r\n    "name": "versions-test",\r\n    "version": "1.0.0",\r\n    "dependencies": [\r\n        {\r\n            "name": "fmt",\r\n            "version>=": "7.1.3#1"\r\n        }, \r\n        "zlib"\r\n    ],\r\n    "builtin-baseline": "3426db05b996481ca31e95fff3734cf23e0f51bc"\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"main.cpp"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <fmt/core.h>\r\n#include <zlib.h>\r\n\r\nint main()\r\n{\r\n    fmt::print("fmt version is {}\\n"\r\n               "zlib version is {}\\n", \r\n               FMT_VERSION, ZLIB_VERSION);\r\n    return 0;\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"CMakeLists.txt"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-CMake",children:"cmake_minimum_required(VERSION 3.18)\r\n\r\nproject(versionstest CXX)\r\n\r\nadd_executable(main main.cpp)\r\n\r\nfind_package(ZLIB REQUIRED)\r\nfind_package(fmt CONFIG REQUIRED)\r\ntarget_link_libraries(main PRIVATE ZLIB::ZLIB fmt::fmt)\n"})}),"\n",(0,s.jsx)(n.p,{children:"And now we build and run our project with CMake:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Create the build directory for the project."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-powershell",children:"PS D:\\versions-test> mkdir build\r\nPS D:\\versions-test> cd build\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Configure CMake."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-powershell",children:"PS D:\\versions-test\\build> cmake -G Ninja -DCMAKE_TOOLCHAIN_FILE=D:/kmpkg/scripts/buildsystems/kmpkg.cmake ..\r\n-- Running kmpkg install\r\nDetecting compiler hash for triplet x86-windows...\r\nThe following packages will be built and installed:\r\n    fmt[core]:x64-windows -> 7.1.3#1 -- D:\\Work\\viromer\\kmpkg\\buildtrees\\versioning\\versions\\fmt\\4f8427eb0bd40da1856d4e67bde39a4fda689d72\r\n    kmpkg-cmake[core]:x64-windows -> 2021-02-26 -- D:\\Work\\viromer\\kmpkg\\buildtrees\\versioning\\versions\\kmpkg-cmake\\51896aa8073adb5c8450daa423d03eedf0dfc61f\r\n    kmpkg-cmake-config[core]:x64-windows -> 2021-02-26 -- D:\\Work\\viromer\\kmpkg\\buildtrees\\versioning\\versions\\kmpkg-cmake-config\\d255b3d566a8861dcc99a958240463e678528066\r\n    zlib[core]:x64-windows -> 1.2.11#9 -- D:\\Work\\viromer\\kmpkg\\buildtrees\\versioning\\versions\\zlib\\827111046e37c98153d9d82bb6fa4183b6d728e4\r\n...\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Build the project."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-powershell",children:"PS D:\\versions-test\\build> cmake --build .\r\n[2/2] Linking CXX executable main.exe\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Run it!"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-powershell",children:"PS D:\\versions-test\\build> ./main.exe\r\nfmt version is 70103\r\nzlib version is 1.2.11\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Take a look at the output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-console",children:"fmt[core]:x86-windows -> 7.1.3#1 -- D:\\kmpkg\\buildtrees\\versioning\\versions\\fmt\\4f8427eb0bd40da1856d4e67bde39a4fda689d72\r\n...\r\nzlib[core]:x86-windows -> 1.2.11#9 -- D:\\kmpkg\\buildtrees\\versioning\\versions\\zlib\\827111046e37c98153d9d82bb6fa4183b6d728e4\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Instead of using the portfiles in ",(0,s.jsx)(n.code,{children:"ports/"}),", kmpkg is checking out the files for each version in ",(0,s.jsx)(n.code,{children:"buildtrees/versioning/versions/"}),". The files in ",(0,s.jsx)(n.code,{children:"ports/"})," are still used when running kmpkg in classic mode."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["[!NOTE]\r\nOutput from kmpkg while configuring CMake is only available when using CMake version ",(0,s.jsx)(n.code,{children:"3.18"})," or newer. If you're using an older CMake you can check the ",(0,s.jsx)(n.code,{children:"kmpkg-manifest-install.log"})," file in your build directory instead."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Read our ",(0,s.jsx)(n.a,{href:"https://devblogs.microsoft.com/cppblog/kmpkg-accelerate-your-team-development-environment-with-binary-caching-and-manifests/#using-manifests-with-msbuild-projects",children:"manifests announcement blog post"})," to learn how to use manifests with MSBuild."]}),"\n",(0,s.jsx)(n.h3,{id:"manifest-changes",children:"Manifest changes"}),"\n",(0,s.jsx)(n.p,{children:"If you have used manifests before you will notice that there are some new JSON properties. Let's review these changes:"}),"\n",(0,s.jsx)(n.h4,{id:"version",children:(0,s.jsx)(n.code,{children:"version"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\r\n    "name": "versions-test",\r\n    "version": "1.0.0"\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This is your project's version declaration. Previously, you could only declare versions for your projects using the ",(0,s.jsx)(n.code,{children:"version-string"})," property. Now that versioning has come around, kmpkg is aware of some new versioning schemes."]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Version scheme"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"version"})}),(0,s.jsxs)(n.td,{children:["Dot-separated numerics: ",(0,s.jsx)(n.code,{children:"1.0.0.5"}),"."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"version-semver"})}),(0,s.jsxs)(n.td,{children:["Compliant ",(0,s.jsx)(n.a,{href:"https://semver.org",children:"semantic versions"}),": ",(0,s.jsx)(n.code,{children:"1.2.0"})," and ",(0,s.jsx)(n.code,{children:"1.2.0-rc"}),"."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"version-date"})}),(0,s.jsxs)(n.td,{children:["Dates in ",(0,s.jsx)(n.code,{children:"YYYY-MM-DD"})," format: ",(0,s.jsx)(n.code,{children:"2021-01-01"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"version-string"})}),(0,s.jsxs)(n.td,{children:["Arbitrary strings: ",(0,s.jsx)(n.code,{children:"vista"}),", ",(0,s.jsx)(n.code,{children:"candy"}),"."]})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"version-1",children:(0,s.jsx)(n.code,{children:"version>="})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\r\n    "dependencies": [\r\n        { "name": "fmt", "version>=": "7.1.3" },\r\n        "zlib"\r\n    ]\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This property is used to express minimum version constraints, it is allowed only as part of the ",(0,s.jsx)(n.code,{children:'"dependencies"'})," declarations. In our example we set an explicit constraint on version ",(0,s.jsx)(n.code,{children:"7.1.3#1"})," of ",(0,s.jsx)(n.code,{children:"fmt"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["kmpkg is allowed to upgrade this constraint if a transitive dependency requires a newer version. For example, if ",(0,s.jsx)(n.code,{children:"zlib"})," were to declare a dependency on ",(0,s.jsx)(n.code,{children:"fmt"})," version ",(0,s.jsx)(n.code,{children:"7.1.4"})," then kmpkg would install ",(0,s.jsx)(n.code,{children:"7.1.4"})," instead."]}),"\n",(0,s.jsxs)(n.p,{children:["kmpkg uses a minimum version approach, in our example, even if ",(0,s.jsx)(n.code,{children:"fmt"})," version ",(0,s.jsx)(n.code,{children:"8.0.0"})," were to be released, kmpkg would still install version ",(0,s.jsx)(n.code,{children:"7.1.3#1"})," as that is the minimum version that satisfies the constraint. The advantages of this approach are that you don't get unexpected dependency upgrades when you update kmpkg and you get reproducible builds (in terms of version used) as long as you use the same manifest."]}),"\n",(0,s.jsx)(n.p,{children:"If you want to upgrade your dependencies, you can bump the minimum version constraint or use a newer baseline."}),"\n",(0,s.jsx)(n.h4,{id:"builtin-baseline",children:(0,s.jsx)(n.code,{children:"builtin-baseline"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{ "builtin-baseline": "3426db05b996481ca31e95fff3734cf23e0f51bc" }\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This field declares the versioning baseline for all ports. Setting a baseline is required to enable versioning, otherwise you will get the current versions on the ",(0,s.jsx)(n.code,{children:"ports/"})," directory. You can run 'git rev-parse HEAD' to get the current commit of kmpkg and set it as the builtin-baseline. See the ",(0,s.jsxs)(n.a,{href:"/docs/next/kmpkg/reference/kmpkg-json#builtin-baseline",children:[(0,s.jsx)(n.code,{children:'"builtin-baseline"'})," documentation"]})," for more information."]}),"\n",(0,s.jsxs)(n.p,{children:["In our example, we do not declare a version constraint for ",(0,s.jsx)(n.code,{children:"zlib"}),"; instead, the version is taken from the baseline. Internally, kmpkg will look in commit ",(0,s.jsx)(n.code,{children:"3426db05b996481ca31e95fff3734cf23e0f51bc"})," to find out what version of ",(0,s.jsx)(n.code,{children:"zlib"})," was the latest at that point in time (in our case it was ",(0,s.jsx)(n.code,{children:"1.2.11#9"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"During version resolution, baseline versions are treated as minimum version constraints. If you declare an explicit constraint that is lower than a baseline version, the explicit constraint will be upgraded to the baseline version."}),"\n",(0,s.jsx)(n.p,{children:"For example, if we modified our dependencies like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{ "dependencies": [\r\n    {\r\n        "name": "fmt",\r\n        "version>=": "7.1.3#1"\r\n    },\r\n    {\r\n        "name": "zlib",\r\n        "version>=": "1.2.11#7"\r\n    }\r\n] }\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["[!NOTE]\r\nThe value ",(0,s.jsx)(n.code,{children:"1.2.11#7"})," represents version ",(0,s.jsx)(n.code,{children:"1.2.11"}),", port version ",(0,s.jsx)(n.code,{children:"7"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Since the baseline introduces a minimum version constraint for ",(0,s.jsx)(n.code,{children:"zlib"})," at ",(0,s.jsx)(n.code,{children:"1.2.11#9"})," and a higher version does satisfy the minimum version constraint for ",(0,s.jsx)(n.code,{children:"1.2.11#7"}),", kmpkg is allowed to upgrade it."]}),"\n",(0,s.jsxs)(n.p,{children:["Baselines are also a convenient mechanism to upgrade multiple versions at a time, for example, if you wanted to depend on multiple ",(0,s.jsx)(n.code,{children:"boost"})," libraries, it is more convenient to set the ",(0,s.jsx)(n.code,{children:"baseline"})," once than declaring a version constraint on each package."]}),"\n",(0,s.jsx)(n.p,{children:"But what if you want to pin a version older than the baseline?"}),"\n",(0,s.jsx)(n.h4,{id:"overrides",children:(0,s.jsx)(n.code,{children:"overrides"})}),"\n",(0,s.jsx)(n.p,{children:"Since baselines establish a version floor for all packages and explicit constraints get upgraded when they are lower than the baseline, we need another mechanism to downgrade versions past the baseline."}),"\n",(0,s.jsxs)(n.p,{children:["The mechanism kmpkg provides for that scenario is ",(0,s.jsx)(n.code,{children:"overrides"}),". When an override is declared on a package, kmpkg will ignore all other version constraints either directly declared in the manifest or from transitive dependencies. In short, ",(0,s.jsx)(n.code,{children:"overrides"})," will force kmpkg to use the exact version declared, period."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's modify our example once more, this time to force kmpkg to use version ",(0,s.jsx)(n.code,{children:"6.0.0"})," of ",(0,s.jsx)(n.code,{children:"fmt"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\r\n    "name": "versions-test",\r\n    "version": "1.0.0",\r\n    "dependencies": [\r\n        {\r\n            "name": "fmt",\r\n            "version>=": "7.1.3#1"\r\n        },\r\n        {\r\n            "name": "zlib",\r\n            "version>=": "1.2.11#7"\r\n        }\r\n    ],\r\n    "builtin-baseline": "3426db05b996481ca31e95fff3734cf23e0f51bc",\r\n    "overrides": [\r\n        {\r\n            "name": "fmt",\r\n            "version": "6.0.0"\r\n        }\r\n    ]\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Rebuild our project:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-powershell",children:"PS D:\\versions-test\\build> rm ./CMakeCache.txt\r\nPS D:\\versions-test\\build> rm -r ./kmpkg_installed\r\nPS D:\\versions-test\\build> cmake -G Ninja -DCMAKE_TOOLCHAIN_FILE=D:/kmpkg/scripts/buildsystems/kmpkg.cmake ..\r\n-- Running kmpkg install\r\nDetecting compiler hash for triplet x86-windows...\r\nThe following packages will be built and installed:\r\n    fmt[core]:x86-windows -> 6.0.0 -- D:\\kmpkg\\buildtrees\\versioning\\versions\\fmt\\d99b6a35e1406ba6b6e09d719bebd086f83ed5f3\r\n    zlib[core]:x86-windows -> 1.2.11#9 -- D:\\kmpkg\\buildtrees\\versioning\\versions\\zlib\\827111046e37c98153d9d82bb6fa4183b6d728e4\r\n...\r\nPS D:\\versions-test\\build> cmake --build .\r\n[2/2] Linking CXX executable main.exe\n"})}),"\n",(0,s.jsx)(n.p,{children:"And run it!"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-powershell",children:"PS D:\\versions-test\\build> .\\main.exe\r\nfmt version is 60000\r\nzlib version is 1.2.11\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Notice how the ",(0,s.jsx)(n.code,{children:"fmt"})," is now at version ",(0,s.jsx)(n.code,{children:"6.0.0"})," just like we wanted."]}),"\n",(0,s.jsx)(n.h2,{id:"versions-and-custom-ports",children:"Versions and custom ports"}),"\n",(0,s.jsx)(n.p,{children:"The last thing to discuss is how overlay ports interact with versioning resolution. The answer is: they don't."}),"\n",(0,s.jsx)(n.p,{children:"Going into more detail, when you provide an overlay for a port, kmpkg will always use the overlay port without caring what version is contained in it. The reasons are two-fold: (1) it is consistent with the existing behavior of overlay ports of completely masking the existing port, and (2) overlay ports do not (and are not expected to) provide enough information to power kmpkg's versioning feature."}),"\n",(0,s.jsxs)(n.p,{children:["If you want to have flexible port customization along with versioning, you should consider ",(0,s.jsx)(n.a,{href:"/docs/next/kmpkg/maintainers/registries",children:"making your own custom registry"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further reading"}),"\n",(0,s.jsxs)(n.p,{children:["If you're interested in delving deeper into the details of how versioning works we recommended that you read our ",(0,s.jsx)(n.a,{href:"/docs/next/kmpkg/users/versioning",children:"Versioning reference"})," and ",(0,s.jsx)(n.a,{href:"/docs/next/kmpkg/users/versioning.concepts",children:"Versioning concepts"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>d});var s=i(96540);const r={},o=s.createContext(r);function t(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);