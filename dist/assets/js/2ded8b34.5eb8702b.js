"use strict";(self.webpackChunkkumo_website=self.webpackChunkkumo_website||[]).push([[85113],{63368:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>o,frontMatter:()=>r,metadata:()=>d,toc:()=>h});var n=s(74848),l=s(28453);const r={},c="Matchers Reference",d={id:"cpp/base/testing/kt/reference/matchers",title:"Matchers Reference",description:"A matcher matches a single argument. You can use it inside ON_CALL() or",source:"@site/docs/cpp/base/testing/kt/reference/matchers.mdx",sourceDirName:"cpp/base/testing/kt/reference",slug:"/cpp/base/testing/kt/reference/matchers",permalink:"/docs/next/cpp/base/testing/kt/reference/matchers",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{}},i={},h=[{value:"Wildcard",id:"wildcard",level:2},{value:"Generic Comparison",id:"generic-comparison",level:2},{value:"Floating-Point Matchers",id:"FpMatchers",level:2},{value:"String Matchers",id:"string-matchers",level:2},{value:"Container Matchers",id:"container-matchers",level:2},{value:"Member Matchers",id:"member-matchers",level:2},{value:"Matching the Result of a Function, Functor, or Callback",id:"matching-the-result-of-a-function-functor-or-callback",level:2},{value:"Pointer Matchers",id:"pointer-matchers",level:2},{value:"Multi-argument Matchers",id:"MultiArgMatchers",level:2},{value:"Composite Matchers",id:"composite-matchers",level:2},{value:"Adapters for Matchers",id:"adapters-for-matchers",level:2},{value:"Using Matchers as Predicates",id:"MatchersAsPredicatesCheat",level:2},{value:"Defining Matchers",id:"defining-matchers",level:2}];function a(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"matchers-reference",children:"Matchers Reference"})}),"\n",(0,n.jsxs)(t.p,{children:["A ",(0,n.jsx)(t.strong,{children:"matcher"})," matches a ",(0,n.jsx)(t.em,{children:"single"})," argument. You can use it inside ",(0,n.jsx)(t.code,{children:"ON_CALL()"})," or\n",(0,n.jsx)(t.code,{children:"EXPECT_CALL()"}),", or use it to validate a value directly using two macros:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Macro"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"EXPECT_THAT(actual_value, matcher)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["Asserts that ",(0,n.jsx)(t.code,{children:"actual_value"})," matches ",(0,n.jsx)(t.code,{children:"matcher"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"ASSERT_THAT(actual_value, matcher)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["The same as ",(0,n.jsx)(t.code,{children:"EXPECT_THAT(actual_value, matcher)"}),", except that it generates a ",(0,n.jsx)(t.strong,{children:"fatal"})," failure."]})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"{: .callout .warning}"}),"\n",(0,n.jsx)(t.strong,{children:"WARNING:"})," Equality matching via ",(0,n.jsx)(t.code,{children:"EXPECT_THAT(actual_value, expected_value)"}),"\nis supported, however note that implicit conversions can cause surprising\nresults. For example, ",(0,n.jsx)(t.code,{children:'EXPECT_THAT(some_bool, "some string")'})," will compile and\nmay pass unintentionally."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"BEST PRACTICE:"})," Prefer to make the comparison explicit via\n",(0,n.jsx)(t.code,{children:"EXPECT_THAT(actual_value, Eq(expected_value))"})," or ",(0,n.jsx)(t.code,{children:"EXPECT_EQ(actual_value, expected_value)"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["Built-in matchers (where ",(0,n.jsx)(t.code,{children:"argument"})," is the function argument, e.g.\n",(0,n.jsx)(t.code,{children:"actual_value"})," in the example above, or when used in the context of\n",(0,n.jsx)(t.code,{children:"EXPECT_CALL(mock_object, method(matchers))"}),", the arguments of ",(0,n.jsx)(t.code,{children:"method"}),") are\ndivided into several categories. All matchers are defined in the ",(0,n.jsx)(t.code,{children:"::testing"}),"\nnamespace unless otherwise noted."]}),"\n",(0,n.jsx)(t.h2,{id:"wildcard",children:"Wildcard"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Matcher"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"_"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," can be any value of the correct type."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"A<type>()"})," or ",(0,n.jsx)(t.code,{children:"An<type>()"})]}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," can be any value of type ",(0,n.jsx)(t.code,{children:"type"}),"."]})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"generic-comparison",children:"Generic Comparison"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Matcher"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"Eq(value)"})," or ",(0,n.jsx)(t.code,{children:"value"})]}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"argument == value"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Ge(value)"})}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"argument >= value"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Gt(value)"})}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"argument > value"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Le(value)"})}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"argument <= value"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Lt(value)"})}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"argument < value"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Ne(value)"})}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"argument != value"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"IsFalse()"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," evaluates to ",(0,n.jsx)(t.code,{children:"false"})," in a Boolean context."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"IsTrue()"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," evaluates to ",(0,n.jsx)(t.code,{children:"true"})," in a Boolean context."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"IsNull()"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a ",(0,n.jsx)(t.code,{children:"NULL"})," pointer (raw or smart)."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"NotNull()"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a non-null pointer (raw or smart)."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Optional(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is ",(0,n.jsx)(t.code,{children:"optional<>"})," that contains a value matching ",(0,n.jsx)(t.code,{children:"m"}),". (For testing whether an ",(0,n.jsx)(t.code,{children:"optional<>"})," is set, check for equality with ",(0,n.jsx)(t.code,{children:"nullopt"}),". You may need to use ",(0,n.jsx)(t.code,{children:"Eq(nullopt)"})," if the inner type doesn't have ",(0,n.jsx)(t.code,{children:"=="}),".)"]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"VariantWith<T>(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is ",(0,n.jsx)(t.code,{children:"variant<>"})," that holds the alternative of type T with a value matching ",(0,n.jsx)(t.code,{children:"m"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Ref(variable)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a reference to ",(0,n.jsx)(t.code,{children:"variable"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"TypedEq<type>(value)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," has type ",(0,n.jsx)(t.code,{children:"type"})," and is equal to ",(0,n.jsx)(t.code,{children:"value"}),". You may need to use this instead of ",(0,n.jsx)(t.code,{children:"Eq(value)"})," when the mock function is overloaded."]})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["Except ",(0,n.jsx)(t.code,{children:"Ref()"}),", these matchers make a ",(0,n.jsx)(t.em,{children:"copy"})," of ",(0,n.jsx)(t.code,{children:"value"})," in case it's modified or\ndestructed later. If the compiler complains that ",(0,n.jsx)(t.code,{children:"value"})," doesn't have a public\ncopy constructor, try wrap it in ",(0,n.jsx)(t.code,{children:"std::ref()"}),", e.g.\n",(0,n.jsx)(t.code,{children:"Eq(std::ref(non_copyable_value))"}),". If you do that, make sure\n",(0,n.jsx)(t.code,{children:"non_copyable_value"})," is not changed afterwards, or the meaning of your matcher\nwill be changed."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"IsTrue"})," and ",(0,n.jsx)(t.code,{children:"IsFalse"})," are useful when you need to use a matcher, or for types\nthat can be explicitly converted to Boolean, but are not implicitly converted to\nBoolean. In other cases, you can use the basic\n",(0,n.jsxs)(t.a,{href:"/docs/next/cpp/base/testing/kt/reference/assertions#boolean",children:[(0,n.jsx)(t.code,{children:"EXPECT_TRUE"})," and ",(0,n.jsx)(t.code,{children:"EXPECT_FALSE"})]})," assertions."]}),"\n",(0,n.jsx)(t.h2,{id:"FpMatchers",children:"Floating-Point Matchers"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Matcher"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"DoubleEq(a_double)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a ",(0,n.jsx)(t.code,{children:"double"})," value approximately equal to ",(0,n.jsx)(t.code,{children:"a_double"}),", treating two NaNs as unequal."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"FloatEq(a_float)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a ",(0,n.jsx)(t.code,{children:"float"})," value approximately equal to ",(0,n.jsx)(t.code,{children:"a_float"}),", treating two NaNs as unequal."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"NanSensitiveDoubleEq(a_double)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a ",(0,n.jsx)(t.code,{children:"double"})," value approximately equal to ",(0,n.jsx)(t.code,{children:"a_double"}),", treating two NaNs as equal."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"NanSensitiveFloatEq(a_float)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a ",(0,n.jsx)(t.code,{children:"float"})," value approximately equal to ",(0,n.jsx)(t.code,{children:"a_float"}),", treating two NaNs as equal."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"IsNan()"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is any floating-point type with a NaN value."]})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["The above matchers use ULP-based comparison (the same as used in googletest).\nThey automatically pick a reasonable error bound based on the absolute value of\nthe expected value. ",(0,n.jsx)(t.code,{children:"DoubleEq()"})," and ",(0,n.jsx)(t.code,{children:"FloatEq()"})," conform to the IEEE standard,\nwhich requires comparing two NaNs for equality to return false. The\n",(0,n.jsx)(t.code,{children:"NanSensitive*"})," version instead treats two NaNs as equal, which is often what a\nuser wants."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Matcher"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"DoubleNear(a_double, max_abs_error)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a ",(0,n.jsx)(t.code,{children:"double"})," value close to ",(0,n.jsx)(t.code,{children:"a_double"})," (absolute error ",(0,n.jsx)(t.code,{children:"<="})," ",(0,n.jsx)(t.code,{children:"max_abs_error"}),"), treating two NaNs as unequal."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"FloatNear(a_float, max_abs_error)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a ",(0,n.jsx)(t.code,{children:"float"})," value close to ",(0,n.jsx)(t.code,{children:"a_float"})," (absolute error ",(0,n.jsx)(t.code,{children:"<="})," ",(0,n.jsx)(t.code,{children:"max_abs_error"}),"), treating two NaNs as unequal."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"NanSensitiveDoubleNear(a_double, max_abs_error)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a ",(0,n.jsx)(t.code,{children:"double"})," value close to ",(0,n.jsx)(t.code,{children:"a_double"})," (absolute error ",(0,n.jsx)(t.code,{children:"<="})," ",(0,n.jsx)(t.code,{children:"max_abs_error"}),"), treating two NaNs as equal."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"NanSensitiveFloatNear(a_float, max_abs_error)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a ",(0,n.jsx)(t.code,{children:"float"})," value close to ",(0,n.jsx)(t.code,{children:"a_float"})," (absolute error ",(0,n.jsx)(t.code,{children:"<="})," ",(0,n.jsx)(t.code,{children:"max_abs_error"}),"), treating two NaNs as equal."]})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"string-matchers",children:"String Matchers"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"argument"})," can be either a C string or a C++ string object:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Matcher"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"ContainsRegex(string)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," matches the given regular expression."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"EndsWith(suffix)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," ends with string ",(0,n.jsx)(t.code,{children:"suffix"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"HasSubstr(string)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," contains ",(0,n.jsx)(t.code,{children:"string"})," as a sub-string."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"IsEmpty()"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is an empty string."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"MatchesRegex(string)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," matches the given regular expression with the match starting at the first character and ending at the last character."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"StartsWith(prefix)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," starts with string ",(0,n.jsx)(t.code,{children:"prefix"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"StrCaseEq(string)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is equal to ",(0,n.jsx)(t.code,{children:"string"}),", ignoring case."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"StrCaseNe(string)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is not equal to ",(0,n.jsx)(t.code,{children:"string"}),", ignoring case."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"StrEq(string)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is equal to ",(0,n.jsx)(t.code,{children:"string"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"StrNe(string)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is not equal to ",(0,n.jsx)(t.code,{children:"string"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"WhenBase64Unescaped(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a base-64 escaped string whose unescaped string matches ",(0,n.jsx)(t.code,{children:"m"}),"."]})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"ContainsRegex()"})," and ",(0,n.jsx)(t.code,{children:"MatchesRegex()"})," take ownership of the ",(0,n.jsx)(t.code,{children:"RE"})," object. They\nuse the regular expression syntax defined\n",(0,n.jsx)(t.a,{href:"/docs/next/cpp/base/testing/kt/advanced#regular-expression-syntax",children:"here"}),". All of these matchers, except\n",(0,n.jsx)(t.code,{children:"ContainsRegex()"})," and ",(0,n.jsx)(t.code,{children:"MatchesRegex()"})," work for wide strings as well."]}),"\n",(0,n.jsx)(t.h2,{id:"container-matchers",children:"Container Matchers"}),"\n",(0,n.jsxs)(t.p,{children:["Most STL-style containers support ",(0,n.jsx)(t.code,{children:"=="}),", so you can use ",(0,n.jsx)(t.code,{children:"Eq(expected_container)"}),"\nor simply ",(0,n.jsx)(t.code,{children:"expected_container"})," to match a container exactly. If you want to\nwrite the elements in-line, match them more flexibly, or get more informative\nmessages, you can use:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Matcher"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"BeginEndDistanceIs(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a container whose ",(0,n.jsx)(t.code,{children:"begin()"})," and ",(0,n.jsx)(t.code,{children:"end()"})," iterators are separated by a number of increments matching ",(0,n.jsx)(t.code,{children:"m"}),". E.g. ",(0,n.jsx)(t.code,{children:"BeginEndDistanceIs(2)"})," or ",(0,n.jsx)(t.code,{children:"BeginEndDistanceIs(Lt(2))"}),". For containers that define a ",(0,n.jsx)(t.code,{children:"size()"})," method, ",(0,n.jsx)(t.code,{children:"SizeIs(m)"})," may be more efficient."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"ContainerEq(container)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["The same as ",(0,n.jsx)(t.code,{children:"Eq(container)"})," except that the failure message also includes which elements are in one container but not the other."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Contains(e)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," contains an element that matches ",(0,n.jsx)(t.code,{children:"e"}),", which can be either a value or a matcher."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Contains(e).Times(n)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," contains elements that match ",(0,n.jsx)(t.code,{children:"e"}),", which can be either a value or a matcher, and the number of matches is ",(0,n.jsx)(t.code,{children:"n"}),", which can be either a value or a matcher. Unlike the plain ",(0,n.jsx)(t.code,{children:"Contains"})," and ",(0,n.jsx)(t.code,{children:"Each"})," this allows to check for arbitrary occurrences including testing for absence with ",(0,n.jsx)(t.code,{children:"Contains(e).Times(0)"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Each(e)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a container where ",(0,n.jsx)(t.em,{children:"every"})," element matches ",(0,n.jsx)(t.code,{children:"e"}),", which can be either a value or a matcher."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"ElementsAre(e0, e1, ..., en)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," has ",(0,n.jsx)(t.code,{children:"n + 1"})," elements, where the ",(0,n.jsx)(t.em,{children:"i"}),"-th element matches ",(0,n.jsx)(t.code,{children:"ei"}),", which can be a value or a matcher."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"ElementsAreArray({e0, e1, ..., en})"}),", ",(0,n.jsx)(t.code,{children:"ElementsAreArray(a_container)"}),", ",(0,n.jsx)(t.code,{children:"ElementsAreArray(begin, end)"}),", ",(0,n.jsx)(t.code,{children:"ElementsAreArray(array)"}),", or ",(0,n.jsx)(t.code,{children:"ElementsAreArray(array, count)"})]}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["The same as ",(0,n.jsx)(t.code,{children:"ElementsAre()"})," except that the expected element values/matchers come from an initializer list, STL-style container, iterator range, or C-style array."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"IsEmpty()"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is an empty container (",(0,n.jsx)(t.code,{children:"container.empty()"}),")."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"IsSubsetOf({e0, e1, ..., en})"}),", ",(0,n.jsx)(t.code,{children:"IsSubsetOf(a_container)"}),", ",(0,n.jsx)(t.code,{children:"IsSubsetOf(begin, end)"}),", ",(0,n.jsx)(t.code,{children:"IsSubsetOf(array)"}),", or ",(0,n.jsx)(t.code,{children:"IsSubsetOf(array, count)"})]}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," matches ",(0,n.jsx)(t.code,{children:"UnorderedElementsAre(x0, x1, ..., xk)"})," for some subset ",(0,n.jsx)(t.code,{children:"{x0, x1, ..., xk}"})," of the expected matchers."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"IsSupersetOf({e0, e1, ..., en})"}),", ",(0,n.jsx)(t.code,{children:"IsSupersetOf(a_container)"}),", ",(0,n.jsx)(t.code,{children:"IsSupersetOf(begin, end)"}),", ",(0,n.jsx)(t.code,{children:"IsSupersetOf(array)"}),", or ",(0,n.jsx)(t.code,{children:"IsSupersetOf(array, count)"})]}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["Some subset of ",(0,n.jsx)(t.code,{children:"argument"})," matches ",(0,n.jsx)(t.code,{children:"UnorderedElementsAre("}),"expected matchers",(0,n.jsx)(t.code,{children:")"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"Pointwise(m, container)"}),", ",(0,n.jsx)(t.code,{children:"Pointwise(m, {e0, e1, ..., en})"})]}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," contains the same number of elements as in ",(0,n.jsx)(t.code,{children:"container"}),", and for all i, (the i-th element in ",(0,n.jsx)(t.code,{children:"argument"}),", the i-th element in ",(0,n.jsx)(t.code,{children:"container"}),") match ",(0,n.jsx)(t.code,{children:"m"}),", which is a matcher on 2-tuples. E.g. ",(0,n.jsx)(t.code,{children:"Pointwise(Le(), upper_bounds)"})," verifies that each element in ",(0,n.jsx)(t.code,{children:"argument"})," doesn't exceed the corresponding element in ",(0,n.jsx)(t.code,{children:"upper_bounds"}),". See more detail below."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"SizeIs(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a container whose size matches ",(0,n.jsx)(t.code,{children:"m"}),". E.g. ",(0,n.jsx)(t.code,{children:"SizeIs(2)"})," or ",(0,n.jsx)(t.code,{children:"SizeIs(Lt(2))"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"UnorderedElementsAre(e0, e1, ..., en)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," has ",(0,n.jsx)(t.code,{children:"n + 1"})," elements, and under ",(0,n.jsx)(t.em,{children:"some"})," permutation of the elements, each element matches an ",(0,n.jsx)(t.code,{children:"ei"})," (for a different ",(0,n.jsx)(t.code,{children:"i"}),"), which can be a value or a matcher."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"UnorderedElementsAreArray({e0, e1, ..., en})"}),", ",(0,n.jsx)(t.code,{children:"UnorderedElementsAreArray(a_container)"}),", ",(0,n.jsx)(t.code,{children:"UnorderedElementsAreArray(begin, end)"}),", ",(0,n.jsx)(t.code,{children:"UnorderedElementsAreArray(array)"}),", or ",(0,n.jsx)(t.code,{children:"UnorderedElementsAreArray(array, count)"})]}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["The same as ",(0,n.jsx)(t.code,{children:"UnorderedElementsAre()"})," except that the expected element values/matchers come from an initializer list, STL-style container, iterator range, or C-style array."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"UnorderedPointwise(m, container)"}),", ",(0,n.jsx)(t.code,{children:"UnorderedPointwise(m, {e0, e1, ..., en})"})]}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["Like ",(0,n.jsx)(t.code,{children:"Pointwise(m, container)"}),", but ignores the order of elements."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"WhenSorted(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["When ",(0,n.jsx)(t.code,{children:"argument"})," is sorted using the ",(0,n.jsx)(t.code,{children:"<"})," operator, it matches container matcher ",(0,n.jsx)(t.code,{children:"m"}),". E.g. ",(0,n.jsx)(t.code,{children:"WhenSorted(ElementsAre(1, 2, 3))"})," verifies that ",(0,n.jsx)(t.code,{children:"argument"})," contains elements 1, 2, and 3, ignoring order."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"WhenSortedBy(comparator, m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["The same as ",(0,n.jsx)(t.code,{children:"WhenSorted(m)"}),", except that the given comparator instead of ",(0,n.jsx)(t.code,{children:"<"})," is used to sort ",(0,n.jsx)(t.code,{children:"argument"}),". E.g. ",(0,n.jsx)(t.code,{children:"WhenSortedBy(std::greater(), ElementsAre(3, 2, 1))"}),"."]})]})]})]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Notes:"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"These matchers can also match:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["a native array passed by reference (e.g. in ",(0,n.jsx)(t.code,{children:"Foo(const int (&a)[5])"}),"),\nand"]}),"\n",(0,n.jsxs)(t.li,{children:["an array passed as a pointer and a count (e.g. in ",(0,n.jsx)(t.code,{children:"Bar(const T* buffer, int len)"})," -- see ",(0,n.jsx)(t.a,{href:"#MultiArgMatchers",children:"Multi-argument Matchers"}),")."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"The array being matched may be multi-dimensional (i.e. its elements can be\narrays)."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"m"})," in ",(0,n.jsx)(t.code,{children:"Pointwise(m, ...)"})," and ",(0,n.jsx)(t.code,{children:"UnorderedPointwise(m, ...)"})," should be a\nmatcher for ",(0,n.jsx)(t.code,{children:"::std::tuple<T, U>"})," where ",(0,n.jsx)(t.code,{children:"T"})," and ",(0,n.jsx)(t.code,{children:"U"})," are the element type of\nthe actual container and the expected container, respectively. For example,\nto compare two ",(0,n.jsx)(t.code,{children:"Foo"})," containers where ",(0,n.jsx)(t.code,{children:"Foo"})," doesn't support ",(0,n.jsx)(t.code,{children:"operator=="}),",\none might write:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:'MATCHER(FooEq, "") {\n  return std::get<0>(arg).Equals(std::get<1>(arg));\n}\n...\nEXPECT_THAT(actual_foos, Pointwise(FooEq(), expected_foos));\n'})}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"member-matchers",children:"Member Matchers"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Matcher"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Field(&class::field, m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument.field"})," (or ",(0,n.jsx)(t.code,{children:"argument->field"})," when ",(0,n.jsx)(t.code,{children:"argument"})," is a plain pointer) matches matcher ",(0,n.jsx)(t.code,{children:"m"}),", where ",(0,n.jsx)(t.code,{children:"argument"})," is an object of type ",(0,n.jsx)(t.em,{children:"class"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Field(field_name, &class::field, m)"})}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"The same as the two-parameter version, but provides a better error message."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Key(e)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument.first"})," matches ",(0,n.jsx)(t.code,{children:"e"}),", which can be either a value or a matcher. E.g. ",(0,n.jsx)(t.code,{children:"Contains(Key(Le(5)))"})," can verify that a ",(0,n.jsx)(t.code,{children:"map"})," contains a key ",(0,n.jsx)(t.code,{children:"<= 5"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Pair(m1, m2)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is an ",(0,n.jsx)(t.code,{children:"std::pair"})," whose ",(0,n.jsx)(t.code,{children:"first"})," field matches ",(0,n.jsx)(t.code,{children:"m1"})," and ",(0,n.jsx)(t.code,{children:"second"})," field matches ",(0,n.jsx)(t.code,{children:"m2"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"FieldsAre(m...)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," is a compatible object where each field matches piecewise with the matchers ",(0,n.jsx)(t.code,{children:"m..."}),". A compatible object is any that supports the ",(0,n.jsx)(t.code,{children:"std::tuple_size<Obj>"}),"+",(0,n.jsx)(t.code,{children:"get<I>(obj)"})," protocol. In C++17 and up this also supports types compatible with structured bindings, like aggregates."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Property(&class::property, m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument.property()"})," (or ",(0,n.jsx)(t.code,{children:"argument->property()"})," when ",(0,n.jsx)(t.code,{children:"argument"})," is a plain pointer) matches matcher ",(0,n.jsx)(t.code,{children:"m"}),", where ",(0,n.jsx)(t.code,{children:"argument"})," is an object of type ",(0,n.jsx)(t.em,{children:"class"}),". The method ",(0,n.jsx)(t.code,{children:"property()"})," must take no argument and be declared as ",(0,n.jsx)(t.code,{children:"const"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Property(property_name, &class::property, m)"})}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"The same as the two-parameter version, but provides a better error message."})]})]})]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Notes:"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["You can use ",(0,n.jsx)(t.code,{children:"FieldsAre()"})," to match any type that supports structured\nbindings, such as ",(0,n.jsx)(t.code,{children:"std::tuple"}),", ",(0,n.jsx)(t.code,{children:"std::pair"}),", ",(0,n.jsx)(t.code,{children:"std::array"}),", and aggregate\ntypes. For example:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:'std::tuple<int, std::string> my_tuple{7, "hello world"};\nEXPECT_THAT(my_tuple, FieldsAre(Ge(0), HasSubstr("hello")));\n\nstruct MyStruct {\n  int value = 42;\n  std::string greeting = "aloha";\n};\nMyStruct s;\nEXPECT_THAT(s, FieldsAre(42, "aloha"));\n'})}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["Don't use ",(0,n.jsx)(t.code,{children:"Property()"})," against member functions that you do not own, because\ntaking addresses of functions is fragile and generally not part of the\ncontract of the function."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"matching-the-result-of-a-function-functor-or-callback",children:"Matching the Result of a Function, Functor, or Callback"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Matcher"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"ResultOf(f, m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"f(argument)"})," matches matcher ",(0,n.jsx)(t.code,{children:"m"}),", where ",(0,n.jsx)(t.code,{children:"f"})," is a function or functor."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"ResultOf(result_description, f, m)"})}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"The same as the two-parameter version, but provides a better error message."})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"pointer-matchers",children:"Pointer Matchers"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Matcher"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Address(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["the result of ",(0,n.jsx)(t.code,{children:"std::addressof(argument)"})," matches ",(0,n.jsx)(t.code,{children:"m"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Pointee(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," (either a smart pointer or a raw pointer) points to a value that matches matcher ",(0,n.jsx)(t.code,{children:"m"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Pointer(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," (either a smart pointer or a raw pointer) contains a pointer that matches ",(0,n.jsx)(t.code,{children:"m"}),". ",(0,n.jsx)(t.code,{children:"m"})," will match against the raw pointer regardless of the type of ",(0,n.jsx)(t.code,{children:"argument"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"WhenDynamicCastTo<T>(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["when ",(0,n.jsx)(t.code,{children:"argument"})," is passed through ",(0,n.jsx)(t.code,{children:"dynamic_cast<T>()"}),", it matches matcher ",(0,n.jsx)(t.code,{children:"m"}),"."]})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"MultiArgMatchers",children:"Multi-argument Matchers"}),"\n",(0,n.jsxs)(t.p,{children:["Technically, all matchers match a ",(0,n.jsx)(t.em,{children:"single"}),' value. A "multi-argument" matcher is\njust one that matches a ',(0,n.jsx)(t.em,{children:"tuple"}),". The following matchers can be used to match a\ntuple ",(0,n.jsx)(t.code,{children:"(x, y)"}),":"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Matcher"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Eq()"})}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"x == y"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Ge()"})}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"x >= y"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Gt()"})}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"x > y"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Le()"})}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"x <= y"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Lt()"})}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"x < y"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Ne()"})}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"x != y"})})]})]})]}),"\n",(0,n.jsx)(t.p,{children:"You can use the following selectors to pick a subset of the arguments (or\nreorder them) to participate in the matching:"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Matcher"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"AllArgs(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["Equivalent to ",(0,n.jsx)(t.code,{children:"m"}),". Useful as syntactic sugar in ",(0,n.jsx)(t.code,{children:".With(AllArgs(m))"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Args<N1, N2, ..., Nk>(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["The tuple of the ",(0,n.jsx)(t.code,{children:"k"})," selected (using 0-based indices) arguments matches ",(0,n.jsx)(t.code,{children:"m"}),", e.g. ",(0,n.jsx)(t.code,{children:"Args<1, 2>(Eq())"}),"."]})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"composite-matchers",children:"Composite Matchers"}),"\n",(0,n.jsx)(t.p,{children:"You can make a matcher from one or more other matchers:"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Matcher"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"AllOf(m1, m2, ..., mn)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," matches all of the matchers ",(0,n.jsx)(t.code,{children:"m1"})," to ",(0,n.jsx)(t.code,{children:"mn"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"AllOfArray({m0, m1, ..., mn})"}),", ",(0,n.jsx)(t.code,{children:"AllOfArray(a_container)"}),", ",(0,n.jsx)(t.code,{children:"AllOfArray(begin, end)"}),", ",(0,n.jsx)(t.code,{children:"AllOfArray(array)"}),", or ",(0,n.jsx)(t.code,{children:"AllOfArray(array, count)"})]}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["The same as ",(0,n.jsx)(t.code,{children:"AllOf()"})," except that the matchers come from an initializer list, STL-style container, iterator range, or C-style array."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"AnyOf(m1, m2, ..., mn)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," matches at least one of the matchers ",(0,n.jsx)(t.code,{children:"m1"})," to ",(0,n.jsx)(t.code,{children:"mn"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"AnyOfArray({m0, m1, ..., mn})"}),", ",(0,n.jsx)(t.code,{children:"AnyOfArray(a_container)"}),", ",(0,n.jsx)(t.code,{children:"AnyOfArray(begin, end)"}),", ",(0,n.jsx)(t.code,{children:"AnyOfArray(array)"}),", or ",(0,n.jsx)(t.code,{children:"AnyOfArray(array, count)"})]}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["The same as ",(0,n.jsx)(t.code,{children:"AnyOf()"})," except that the matchers come from an initializer list, STL-style container, iterator range, or C-style array."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Not(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"argument"})," doesn't match matcher ",(0,n.jsx)(t.code,{children:"m"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Conditional(cond, m1, m2)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["Matches matcher ",(0,n.jsx)(t.code,{children:"m1"})," if ",(0,n.jsx)(t.code,{children:"cond"})," evaluates to true, else matches ",(0,n.jsx)(t.code,{children:"m2"}),"."]})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"adapters-for-matchers",children:"Adapters for Matchers"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Matcher"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"MatcherCast<T>(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["casts matcher ",(0,n.jsx)(t.code,{children:"m"})," to type ",(0,n.jsx)(t.code,{children:"Matcher<T>"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"SafeMatcherCast<T>(m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.a,{href:"/docs/next/cpp/base/testing/kt/kmock_cook_book#SafeMatcherCast",children:"safely casts"})," matcher ",(0,n.jsx)(t.code,{children:"m"})," to type ",(0,n.jsx)(t.code,{children:"Matcher<T>"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Truly(predicate)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.code,{children:"predicate(argument)"})," returns something considered by C++ to be true, where ",(0,n.jsx)(t.code,{children:"predicate"})," is a function or functor."]})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"AddressSatisfies(callback)"})," and ",(0,n.jsx)(t.code,{children:"Truly(callback)"})," take ownership of ",(0,n.jsx)(t.code,{children:"callback"}),",\nwhich must be a permanent callback."]}),"\n",(0,n.jsx)(t.h2,{id:"MatchersAsPredicatesCheat",children:"Using Matchers as Predicates"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Matcher"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Matches(m)(value)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["evaluates to ",(0,n.jsx)(t.code,{children:"true"})," if ",(0,n.jsx)(t.code,{children:"value"})," matches ",(0,n.jsx)(t.code,{children:"m"}),". You can use ",(0,n.jsx)(t.code,{children:"Matches(m)"})," alone as a unary functor."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"ExplainMatchResult(m, value, result_listener)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["evaluates to ",(0,n.jsx)(t.code,{children:"true"})," if ",(0,n.jsx)(t.code,{children:"value"})," matches ",(0,n.jsx)(t.code,{children:"m"}),", explaining the result to ",(0,n.jsx)(t.code,{children:"result_listener"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"Value(value, m)"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["evaluates to ",(0,n.jsx)(t.code,{children:"true"})," if ",(0,n.jsx)(t.code,{children:"value"})," matches ",(0,n.jsx)(t.code,{children:"m"}),"."]})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"defining-matchers",children:"Defining Matchers"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Macro"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:'MATCHER(IsEven, "") { return (arg % 2) == 0; }'})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["Defines a matcher ",(0,n.jsx)(t.code,{children:"IsEven()"})," to match an even number."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:'MATCHER_P(IsDivisibleBy, n, "") { *result_listener << "where the remainder is " << (arg % n); return (arg % n) == 0; }'})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["Defines a matcher ",(0,n.jsx)(t.code,{children:"IsDivisibleBy(n)"})," to match a number divisible by ",(0,n.jsx)(t.code,{children:"n"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:'MATCHER_P2(IsBetween, a, b, absl::StrCat(negation ? "isn\'t" : "is", " between ", PrintToString(a), " and ", PrintToString(b))) { return a <= arg && arg <= b; }'})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["Defines a matcher ",(0,n.jsx)(t.code,{children:"IsBetween(a, b)"})," to match a value in the range [",(0,n.jsx)(t.code,{children:"a"}),", ",(0,n.jsx)(t.code,{children:"b"}),"]."]})]})]})]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Notes:"})}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"MATCHER*"})," macros cannot be used inside a function or class."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The matcher body must be ",(0,n.jsx)(t.em,{children:"purely functional"})," (i.e. it cannot have any side\neffect, and the result must not depend on anything other than the value\nbeing matched and the matcher parameters)."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["You can use ",(0,n.jsx)(t.code,{children:"PrintToString(x)"})," to convert a value ",(0,n.jsx)(t.code,{children:"x"})," of any type to a\nstring."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["You can use ",(0,n.jsx)(t.code,{children:"ExplainMatchResult()"})," in a custom matcher to wrap another\nmatcher, for example:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:'MATCHER_P(NestedPropertyMatches, matcher, "") {\n  return ExplainMatchResult(matcher, arg.nested().property(), result_listener);\n}\n'})}),"\n"]}),"\n"]})]})}function o(e={}){const{wrapper:t}={...(0,l.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>c,x:()=>d});var n=s(96540);const l={},r=n.createContext(l);function c(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:c(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);