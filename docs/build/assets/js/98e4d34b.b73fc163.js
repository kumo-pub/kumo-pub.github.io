"use strict";(self.webpackChunkkumo_website=self.webpackChunkkumo_website||[]).push([[5598],{10165:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var t=a(74848),s=a(28453);const i={},r="Aggregate Functions",o={id:"pollux/functions/presto/aggregate",title:"Aggregate Functions",description:"\u805a\u5408\u51fd\u6570\u5bf9\u4e00\u7ec4\u503c\u8fdb\u884c\u8fd0\u7b97\u4ee5\u8ba1\u7b97\u5355\u4e2a\u7ed3\u679c\u3002",source:"@site/versioned_docs/version-1.1.1/pollux/functions/presto/aggregate.mdx",sourceDirName:"pollux/functions/presto",slug:"/pollux/functions/presto/aggregate",permalink:"/docs/pollux/functions/presto/aggregate",draft:!1,unlisted:!1,tags:[],version:"1.1.1",lastUpdatedBy:"Jeff lothar",lastUpdatedAt:1748143706e3,frontMatter:{},sidebar:"docs",previous:{title:"JSON Functions",permalink:"/docs/pollux/functions/presto/json"},next:{title:"Array Functions",permalink:"/docs/pollux/functions/presto/array"}},l={},c=[{value:"General Aggregate Functions",id:"general-aggregate-functions",level:2},{value:"Bitwise Aggregate Functions",id:"bitwise-aggregate-functions",level:2},{value:"Map Aggregate Functions",id:"map-aggregate-functions",level:2},{value:"Approximate Aggregate Functions",id:"approximate-aggregate-functions",level:2},{value:"Classification Metrics Aggregate Functions",id:"classification-metrics-aggregate-functions",level:2},{value:"Statistical Aggregate Functions",id:"statistical-aggregate-functions",level:2},{value:"Miscellaneous",id:"miscellaneous",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"aggregate-functions",children:"Aggregate Functions"})}),"\n",(0,t.jsx)(n.p,{children:"\u805a\u5408\u51fd\u6570\u5bf9\u4e00\u7ec4\u503c\u8fdb\u884c\u8fd0\u7b97\u4ee5\u8ba1\u7b97\u5355\u4e2a\u7ed3\u679c\u3002"}),"\n",(0,t.jsxs)(n.p,{children:["\u9664\u4e86 :func:",(0,t.jsx)(n.code,{children:"count"}),"\u3001:func:",(0,t.jsx)(n.code,{children:"count_if"}),"\u3001:func:",(0,t.jsx)(n.code,{children:"max_by"}),"\u3001:func:",(0,t.jsx)(n.code,{children:"min_by"})," \u548c\n:func:",(0,t.jsx)(n.code,{children:"approx_distinct"})," \u4e4b\u5916\uff0c\u6240\u6709\u8fd9\u4e9b\u805a\u5408\u51fd\u6570\u90fd\u4f1a\u5ffd\u7565\u7a7a\u503c\uff0c\n\u5e76\u4e14\u5728\u6ca1\u6709\u8f93\u5165\u884c\u6216\u6240\u6709\u503c\u90fd\u4e3a\u7a7a\u65f6\u8fd4\u56de\u7a7a\u503c\u3002\u4f8b\u5982\uff0c\n:func:",(0,t.jsx)(n.code,{children:"sum"})," \u8fd4\u56de\u7a7a\u503c\u800c\u4e0d\u662f\u96f6\uff0c\u800c :func:",(0,t.jsx)(n.code,{children:"avg"})," \u7684\u8ba1\u6570\u4e0d\u5305\u542b\u7a7a\u503c\u3002",(0,t.jsx)(n.code,{children:"coalesce"})," \u51fd\u6570\u53ef\u7528\u4e8e\u5c06\u7a7a\u503c\u8f6c\u6362\u4e3a\n\u96f6\u3002"]}),"\n",(0,t.jsxs)(n.p,{children:["\u67d0\u4e9b\u805a\u5408\u51fd\u6570\uff08\u4f8b\u5982 :func:",(0,t.jsx)(n.code,{children:"array_agg"}),"\uff09\u4f1a\u6839\u636e\u8f93\u5165\u503c\u7684\u987a\u5e8f\u4ea7\u751f\u4e0d\u540c\u7684\u7ed3\u679c\u3002"]}),"\n",(0,t.jsx)(n.h2,{id:"general-aggregate-functions",children:"General Aggregate Functions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    arbitrary(x) -> [same as x]\n\n    Returns an arbitrary non-null value of ``x``, if one exists.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    any_value(x) -> [same as x]\n\n    This is an alias for :func:`arbitrary`.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    array_agg(x) -> array<[same as x]>\n\n    Returns an array created from the input ``x`` elements. Ignores null\n    inputs if :doc:`presto.array_agg.ignore_nulls <../../configs>` is set\n    to false.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    avg(x) -> double|real\n\n    Returns the average (arithmetic mean) of all non-null input values.\n    When x is of type REAL, the result type is REAL.\n    For all other input types, the result type is DOUBLE.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    bool_and(boolean) -> boolean\n\n    Returns ``TRUE`` if every input value is ``TRUE``, otherwise ``FALSE``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    bool_or(boolean) -> boolean\n\n    Returns ``TRUE`` if any input value is ``TRUE``, otherwise ``FALSE``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    checksum(x) -> varbinary\n\n    Returns an order-insensitive checksum of the given values.\n\n```cpp\n    count(*) -> bigint\n\n    Returns the number of input rows.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    count(x) -> bigint\n    :noindex:\n\n    Returns the number of non-null input values.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    count_if(x) -> bigint\n\n    Returns the number of ``TRUE`` input values.\n    This function is equivalent to ``count(CASE WHEN x THEN 1 END)``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    entropy(c) -> double\n\n    Returns the log-2 entropy of count input-values.\n\n    .. math::\n\n        \\mathrm{entropy}(c) = \\sum_i \\left[ {c_i \\over \\sum_j [c_j]} \\log_2\\left({\\sum_j [c_j] \\over c_i}\\right) \\right].\n\n    ``c`` must be a ``integer`` column of non-negative values.\n\n    The function ignores any ``NULL`` count. If the sum of non-``NULL`` counts is 0,\n    it returns 0.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    every(boolean) -> boolean\n\n    This is an alias for :func:`bool_and`.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    histogram(x)\n\n    Returns a map containing the count of the number of times\n    each input value occurs. Supports integral, floating-point,\n    boolean, timestamp, and date input types.\n\n```cpp\n    geometric_mean(bigint) -> double\n              geometric_mean(double) -> double\n              geometric_mean(real) -> real\n\n    Returns the `geometric mean <https://en.wikipedia.org/wiki/Geometric_mean>`_ of all input values.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    max_by(x, y) -> [same as x]\n\n    Returns the value of ``x`` associated with the maximum value of ``y`` over all input values.\n    ``y`` must be an orderable type.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    max_by(x, y, n) -> array([same as x])\n    :noindex:\n\n    Returns n values of ``x`` associated with the n largest values of ``y`` in descending order of ``y``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    min_by(x, y) -> [same as x]\n\n    Returns the value of ``x`` associated with the minimum value of ``y`` over all input values.\n    ``y`` must be an orderable type.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    min_by(x, y, n) -> array([same as x])\n    :noindex:\n\n    Returns n values of ``x`` associated with the n smallest values of ``y`` in ascending order of ``y``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    max(x) -> [same as x]\n\n    Returns the maximum value of all input values.\n    ``x`` must not contain nulls when it is complex type.\n    ``x`` must be an orderable type.\n    Nulls are ignored if there are any non-null inputs.\n    For REAL and DOUBLE types, NaN is considered greater than Infinity.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    max(x, n) -> array<[same as x]>\n    :noindex:\n\n    Returns ``n`` largest values of all input values of ``x``.\n    ``n`` must be a positive integer and not exceed 10'000.\n    Currently not supported for ARRAY, MAP, and ROW input types.\n    Nulls are not included in the output array.\n    For REAL and DOUBLE types, NaN is considered greater than Infinity.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    min(x) -> [same as x]\n\n    Returns the minimum value of all input values.\n    ``x`` must not contain nulls when it is complex type.\n    ``x`` must be an orderable type.\n    Nulls are ignored if there are any non-null inputs.\n    For REAL and DOUBLE types, NaN is considered greater than Infinity.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    min(x, n) -> array<[same as x]>\n    :noindex:\n\n    Returns ``n`` smallest values of all input values of ``x``.\n    ``n`` must be a positive integer and not exceed 10'000.\n    Currently not supported for ARRAY, MAP, and ROW input types.\n    Nulls are not included in output array.\n    For REAL and DOUBLE types, NaN is considered greater than Infinity.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    multimap_agg(K key, V value) -> map(K,array(V))\n\n    Returns a multimap created from the input ``key`` / ``value`` pairs.\n    Each key can be associated with multiple values.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    reduce_agg(inputValue T, initialState S, inputFunction(S,T,S), combineFunction(S,S,S)) -> S\n\n    Reduces all non-NULL input values into a single value. ``inputFunction``\n    will be invoked for each non-NULL input value. If all inputs are NULL, the\n    result is NULL. In addition to taking the input value, ``inputFunction``\n    takes the current state, initially ``initialState``, and returns the new state.\n    ``combineFunction`` will be invoked to combine two states into a new state.\n    The final state is returned. Throws an error if ``initialState`` is NULL or\n    ``inputFunction`` or ``combineFunction`` returns a NULL.\n\n    Take care when designing ``initialState``, ``inputFunction`` and ``combineFunction``.\n    These need to support evaluating aggregation in a distributed manner using partial\n    aggregation on many nodes, followed by shuffle over group-by keys, followed by\n    final aggregation. Given a set of all possible values of state, make sure that\n    combineFunction is `commutative <https://en.wikipedia.org/wiki/Commutative_property>`_\n    and `associative <https://en.wikipedia.org/wiki/Associative_property>`_\n    operation with initialState as the\n    `identity <https://en.wikipedia.org/wiki/Identity_element>`_ value.\n\n     combineFunction(s, initialState) = s for any s\n\n     combineFunction(s1, s2) = combineFunction(s2, s1) for any s1 and s2\n\n     combineFunction(s1, combineFunction(s2, s3)) = combineFunction(combineFunction(s1, s2), s3) for any s1, s2, s3\n\n    In addition, make sure that the following holds for the inputFunction:\n\n     inputFunction(inputFunction(initialState, x), y) = combineFunction(inputFunction(initialState, x), inputFunction(initialState, y)) for any x and y\n\n    Check out `blog post about reduce_agg <https://pollux-lib.io/blog/reduce-agg>`_ for more context.\n\n    Note that reduce_agg doesn't support evaluation over sorted inputs.::\n\n        -- Compute sum (for illustration purposes only; use SUM aggregate function in production queries).\n        SELECT id, reduce_agg(value, 0, (a, b) -> a + b, (a, b) -> a + b)\n        FROM (\n            VALUES\n                (1, 2),\n                (1, 3),\n                (1, 4),\n                (2, 20),\n                (2, 30),\n                (2, 40)\n        ) AS t(id, value)\n        GROUP BY id;\n        -- (1, 9)\n        -- (2, 90)\n\n        -- Compute product.\n        SELECT id, reduce_agg(value, 1, (a, b) -> a * b, (a, b) -> a * b)\n        FROM (\n            VALUES\n                (1, 2),\n                (1, 3),\n                (1, 4),\n                (2, 20),\n                (2, 30),\n                (2, 40)\n        ) AS t(id, value)\n        GROUP BY id;\n        -- (1, 24)\n        -- (2, 24000)\n\n        -- Compute avg (for illustration purposes only; use AVG aggregate function in production queries).\n        SELECT id, sum_and_count.sum / sum_and_count.count FROM (\n          SELECT id, reduce_agg(value, CAST(row(0, 0) AS row(sum double, count bigint)),\n            (s, x) -> CAST(row(s.sum + x, s.count + 1) AS row(sum double, count bigint)),\n            (s, s2) -> CAST(row(s.sum + s2.sum, s.count + s2.count) AS row(sum double, count bigint))) AS sum_and_count\n          FROM (\n               VALUES\n                   (1, 2),\n                   (1, 3),\n                   (1, 4),\n                   (2, 20),\n                   (2, 30),\n                   (2, 40)\n           ) AS t(id, value)\n           GROUP BY id\n        );\n        -- (1, 3.0)\n        -- (2, 30.0)\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    set_agg(x) -> array<[same as x]>\n\n    Returns an array created from the distinct input ``x`` elements.\n    ``x`` must not contain nulls when it is complex type.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    set_union(array(T)) -> array(T)\n\n    Returns an array of all the distinct values contained in each array of the input.\n\n    Returns an empty array if all input arrays are NULL.\n\n    Example::\n\n        SELECT set_union(elements)\n        FROM (\n            VALUES\n                ARRAY[1, 2, 3],\n                ARRAY[2, 3, 4]\n        ) AS t(elements);\n\n    Returns ARRAY[1, 2, 3, 4]\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    sum(x) -> [same as x]\n\n    Returns the sum of all input values.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"bitwise-aggregate-functions",children:"Bitwise Aggregate Functions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    bitwise_and_agg(x) -> [same as x]\n\n    Returns the bitwise AND of all input values in 2's complement representation.\n\n    Supported types are TINYINT, SMALLINT, INTEGER and BIGINT.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    bitwise_or_agg(x) -> [same as x]\n\n    Returns the bitwise OR of all input values in 2's complement representation.\n\n    Supported types are TINYINT, SMALLINT, INTEGER and BIGINT.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    bitwise_xor_agg(x) -> [same as x]\n\n    Returns the bitwise XOR of all input values in 2's complement representation.\n\n    Supported types are TINYINT, SMALLINT, INTEGER and BIGINT.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"map-aggregate-functions",children:"Map Aggregate Functions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    map_agg(K key, V value) -> map(K,V)\n\n    Returns a map created from the input ``key`` / ``value`` pairs. Inputs with NULL or duplicate keys are ignored.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    map_union(map(K,V)) -> map(K,V)\n\n    Returns the union of all the input ``maps``.\n    If a ``key`` is found in multiple input ``maps``,\n    that ``key\u2019s`` ``value`` in the resulting ``map`` comes from an arbitrary input ``map``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    map_union_sum(map(K,V)) -> map(K,V)\n\n    Returns the union of all the input maps summing the values of matching keys in all\n    the maps. All null values in the original maps are coalesced to 0.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"approximate-aggregate-functions",children:"Approximate Aggregate Functions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    approx_distinct(x) -> bigint\n\n    Returns the approximate number of distinct input values.\n    This function provides an approximation of ``count(DISTINCT x)``.\n    Zero is returned if all input values are null.\n\n    This function should produce a standard error of 2.3%, which is the\n    standard deviation of the (approximately normal) error distribution over\n    all possible sets. It does not guarantee an upper bound on the error for\n    any specific input set.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    approx_distinct(x, e) -> bigint\n   :noindex:\n\n    Returns the approximate number of distinct input values.\n    This function provides an approximation of ``count(DISTINCT x)``.\n    Zero is returned if all input values are null.\n\n    This function should produce a standard error of no more than ``e``, which\n    is the standard deviation of the (approximately normal) error distribution\n    over all possible sets. It does not guarantee an upper bound on the error\n    for any specific input set. The current implementation of this function\n    requires that ``e`` be in the range of ``[0.0040625, 0.26000]``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    approx_most_frequent(buckets, value, capacity) -> map<[same as value], bigint>\n\n    Computes the top frequent values up to ``buckets`` elements approximately.\n    Approximate estimation of the function enables us to pick up the frequent\n    values with less memory.  Larger ``capacity`` improves the accuracy of\n    underlying algorithm with sacrificing the memory capacity.  The returned\n    value is a map containing the top elements with corresponding estimated\n    frequency.\n\n    For BOOLEAN 'value', this function always returns 'perfect' result.\n    'bucket' and 'capacity' arguments are ignored in this case.\n\n    The error of the function depends on the permutation of the values and its\n    cardinality.  We can set the capacity same as the cardinality of the\n    underlying data to achieve the least error.\n\n    ``buckets`` and ``capacity`` must be ``bigint``.  ``value`` can be numeric\n    or string type.\n\n    The function uses the stream summary data structure proposed in the paper\n    `Efficient computation of frequent and top-k elements in data streams`__\n    by A. Metwally, D. Agrawal and A. Abbadi.\n\n__ https://www.cse.ust.hk/~raywong/comp5331/References/EfficientComputationOfFrequentAndTop-kElementsInDataStreams.pdf\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    approx_percentile(x, percentage) -> [same as x]\n\n    Returns the approximate percentile for all input values of ``x`` at the\n    given ``percentage``. The value of ``percentage`` must be between zero and\n    one and must be constant for all input rows.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'    approx_percentile(x, percentage, accuracy) -> [same as x]\n   :noindex:\n\n    As ``approx_percentile(x, percentage)``, but with a maximum rank\n    error of ``accuracy``. The value of ``accuracy`` must be between\n    zero and one (exclusive) and must be constant for all input rows.\n    Note that a lower "accuracy" is really a lower error threshold,\n    and thus more accurate.  The default accuracy is 0.0133.  The\n    underlying implementation is KLL sketch thus has a stronger\n    guarantee for accuracy than T-Digest.\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    approx_percentile(x, percentages) -> array<[same as x]>\n   :noindex:\n\n    Returns the approximate percentile for all input values of ``x`` at each of\n    the specified percentages. Each element of the ``percentages`` array must be\n    between zero and one, and the array must be constant for all input rows.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    approx_percentile(x, percentages, accuracy) -> array<[same as x]>\n   :noindex:\n\n    As ``approx_percentile(x, percentages)``, but with a maximum rank error of\n    ``accuracy``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    approx_percentile(x, w, percentage) -> [same as x]\n   :noindex:\n\n    Returns the approximate weighed percentile for all input values of ``x``\n    using the per-item weight ``w`` at the percentage ``p``. The weight must be\n    an integer value of at least one. It is effectively a replication count for\n    the value ``x`` in the percentile set. The value of ``p`` must be between\n    zero and one and must be constant for all input rows.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    approx_percentile(x, w, percentage, accuracy) -> [same as x]\n   :noindex:\n\n    As ``approx_percentile(x, w, percentage)``, but with a maximum\n    rank error of ``accuracy``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    approx_percentile(x, w, percentages) -> array<[same as x]>\n   :noindex:\n\n    Returns the approximate weighed percentile for all input values of ``x``\n    using the per-item weight ``w`` at each of the given percentages specified\n    in the array. The weight must be an integer value of at least one. It is\n    effectively a replication count for the value ``x`` in the percentile\n    set. Each element of the array must be between zero and one, and the array\n    must be constant for all input rows.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    approx_percentile(x, w, percentages, accuracy) -> array<[same as x]>\n   :noindex:\n\n    As ``approx_percentile(x, w, percentages)``, but with a maximum rank error\n    of ``accuracy``.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"classification-metrics-aggregate-functions",children:"Classification Metrics Aggregate Functions"}),"\n",(0,t.jsxs)(n.p,{children:["The following functions each measure how some metric of a binary\n",(0,t.jsx)(n.code,{children:"confusion matrix <https://en.wikipedia.org/wiki/Confusion_matrix>"}),"_ changes as a function of\nclassification thresholds. They are meant to be used in conjunction."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, to find the ",(0,t.jsx)(n.code,{children:"precision-recall curve <https://en.wikipedia.org/wiki/Precision_and_recall>"}),"_, use"]}),"\n",(0,t.jsx)(n.p,{children:".. code-block:: none"}),"\n",(0,t.jsx)(n.p,{children:"WITH\nrecall_precision AS (\nSELECT\nCLASSIFICATION_RECALL(10000, correct, pred) AS recalls,\nCLASSIFICATION_PRECISION(10000, correct, pred) AS precisions\nFROM\nclassification_dataset\n)\nSELECT\nrecall,\nprecision\nFROM\nrecall_precision\nCROSS JOIN UNNEST(recalls, precisions) AS t(recall, precision)"}),"\n",(0,t.jsx)(n.p,{children:"To get the corresponding thresholds for these values, use"}),"\n",(0,t.jsx)(n.p,{children:".. code-block:: none"}),"\n",(0,t.jsx)(n.p,{children:"WITH\nrecall_precision AS (\nSELECT\nCLASSIFICATION_THRESHOLDS(10000, correct, pred) AS thresholds,\nCLASSIFICATION_RECALL(10000, correct, pred) AS recalls,\nCLASSIFICATION_PRECISION(10000, correct, pred) AS precisions\nFROM\nclassification_dataset\n)\nSELECT\nthreshold,\nrecall,\nprecision\nFROM\nrecall_precision\nCROSS JOIN UNNEST(thresholds, recalls, precisions) AS t(threshold, recall, precision)"}),"\n",(0,t.jsxs)(n.p,{children:["To find the ",(0,t.jsx)(n.code,{children:"ROC curve <https://en.wikipedia.org/wiki/Receiver_operating_characteristic>"}),"_, use"]}),"\n",(0,t.jsx)(n.p,{children:".. code-block:: none"}),"\n",(0,t.jsx)(n.p,{children:"WITH\nfallout_recall AS (\nSELECT\nCLASSIFICATION_FALLOUT(10000, correct, pred) AS fallouts,\nCLASSIFICATION_RECALL(10000, correct, pred) AS recalls\nFROM\nclassification_dataset\n)\nSELECT\nfallout\nrecall,\nFROM\nrecall_fallout\nCROSS JOIN UNNEST(fallouts, recalls) AS t(fallout, recall)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    classification_miss_rate(buckets, y, x, weight) -> array<double>\n\n    Computes the miss-rate with up to ``buckets`` number of buckets. Returns\n    an array of miss-rate values.\n\n    ``y`` should be a boolean outcome value; ``x`` should be predictions, each\n    between 0 and 1; ``weight`` should be non-negative values, indicating the weight of the instance.\n\n    The\n    `miss-rate <https://en.wikipedia.org/wiki/Type_I_and_type_II_errors#False_positive_and_false_negative_rates>`_\n    is defined as a sequence whose :math:`j`-th entry is\n\n    .. math ::\n\n        {\n            \\sum_{i \\;|\\; x_i \\leq t_j \\bigwedge y_i = 1} \\left[ w_i \\right]\n            \\over\n            \\sum_{i \\;|\\; x_i \\leq t_j \\bigwedge y_i = 1} \\left[ w_i \\right]\n            +\n            \\sum_{i \\;|\\; x_i > t_j \\bigwedge y_i = 1} \\left[ w_i \\right]\n        },\n\n    where :math:`t_j` is the :math:`j`-th smallest threshold,\n    and :math:`y_i`, :math:`x_i`, and :math:`w_i` are the :math:`i`-th\n    entries of ``y``, ``x``, and ``weight``, respectively.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    classification_miss_rate(buckets, y, x) -> array<double>\n\n    This function is equivalent to the variant of\n    :func:`!classification_miss_rate` that takes a ``weight``, with a per-item weight of ``1``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    classification_fall_out(buckets, y, x, weight) -> array<double>\n\n    Computes the fall-out with up to ``buckets`` number of buckets. Returns\n    an array of fall-out values.\n\n    ``y`` should be a boolean outcome value; ``x`` should be predictions, each\n    between 0 and 1; ``weight`` should be non-negative values, indicating the weight of the instance.\n\n    The\n    `fall-out <https://en.wikipedia.org/wiki/Information_retrieval#Fall-out>`_\n    is defined as a sequence whose :math:`j`-th entry is\n\n    .. math ::\n\n        {\n            \\sum_{i \\;|\\; x_i > t_j \\bigwedge y_i = 0} \\left[ w_i \\right]\n            \\over\n            \\sum_{i \\;|\\; y_i = 0} \\left[ w_i \\right]\n        },\n\n    where :math:`t_j` is the :math:`j`-th smallest threshold,\n    and :math:`y_i`, :math:`x_i`, and :math:`w_i` are the :math:`i`-th\n    entries of ``y``, ``x``, and ``weight``, respectively.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    classification_fall_out(buckets, y, x) -> array<double>\n\n    This function is equivalent to the variant of\n    :func:`!classification_fall_out` that takes a ``weight``, with a per-item weight of ``1``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    classification_precision(buckets, y, x, weight) -> array<double>\n\n    Computes the precision with up to ``buckets`` number of buckets. Returns\n    an array of precision values.\n\n    ``y`` should be a boolean outcome value; ``x`` should be predictions, each\n    between 0 and 1; ``weight`` should be non-negative values, indicating the weight of the instance.\n\n    The\n    `precision <https://en.wikipedia.org/wiki/Positive_and_negative_predictive_values>`_\n    is defined as a sequence whose :math:`j`-th entry is\n\n    .. math ::\n\n        {\n            \\sum_{i \\;|\\; x_i > t_j \\bigwedge y_i = 1} \\left[ w_i \\right]\n            \\over\n            \\sum_{i \\;|\\; x_i > t_j} \\left[ w_i \\right]\n        },\n\n    where :math:`t_j` is the :math:`j`-th smallest threshold,\n    and :math:`y_i`, :math:`x_i`, and :math:`w_i` are the :math:`i`-th\n    entries of ``y``, ``x``, and ``weight``, respectively.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    classification_precision(buckets, y, x) -> array<double>\n\n    This function is equivalent to the variant of\n    :func:`!classification_precision` that takes a ``weight``, with a per-item weight of ``1``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    classification_recall(buckets, y, x, weight) -> array<double>\n\n    Computes the recall with up to ``buckets`` number of buckets. Returns\n    an array of recall values.\n\n    ``y`` should be a boolean outcome value; ``x`` should be predictions, each\n    between 0 and 1; ``weight`` should be non-negative values, indicating the weight of the instance.\n\n    The\n    `recall <https://en.wikipedia.org/wiki/Precision_and_recall#Recall>`_\n    is defined as a sequence whose :math:`j`-th entry is\n\n    .. math ::\n\n        {\n            \\sum_{i \\;|\\; x_i > t_j \\bigwedge y_i = 1} \\left[ w_i \\right]\n            \\over\n            \\sum_{i \\;|\\; y_i = 1} \\left[ w_i \\right]\n        },\n\n    where :math:`t_j` is the :math:`j`-th smallest threshold,\n    and :math:`y_i`, :math:`x_i`, and :math:`w_i` are the :math:`i`-th\n    entries of ``y``, ``x``, and ``weight``, respectively.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    classification_recall(buckets, y, x) -> array<double>\n\n    This function is equivalent to the variant of\n    :func:`!classification_recall` that takes a ``weight``, with a per-item weight of ``1``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    classification_thresholds(buckets, y, x) -> array<double>\n\n    Computes the thresholds with up to ``buckets`` number of buckets. Returns\n    an array of threshold values.\n\n    ``y`` should be a boolean outcome value; ``x`` should be predictions, each\n    between 0 and 1.\n\n    The thresholds are defined as a sequence whose :math:`j`-th entry is the :math:`j`-th smallest threshold.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"statistical-aggregate-functions",children:"Statistical Aggregate Functions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    corr(y, x) -> double\n\n    Returns correlation coefficient of input values.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    covar_pop(y, x) -> double\n\n    Returns the population covariance of input values.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    covar_samp(y, x) -> double\n\n    Returns the sample covariance of input values.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    kurtosis(x) -> double\n\n    Returns the excess kurtosis of all input values. Unbiased estimate using\n    the following expression:\n\n    .. math::\n\n        \\mathrm{kurtosis}(x) = {n(n+1) \\over (n-1)(n-2)(n-3)} { \\sum[(x_i-\\mu)^4] \\over \\sigma^4} -3{ (n-1)^2 \\over (n-2)(n-3) },\n\n   where :math:`\\mu` is the mean, and :math:`\\sigma` is the standard deviation.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regr_avgx(y, x) -> double\n\n    Returns the average of the independent value in a group. ``y`` is the dependent\n    value. ``x`` is the independent value.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regr_avgy(y, x) -> double\n\n    Returns the average of the dependent value in a group. ``y`` is the dependent\n    value. ``x`` is the independent value.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regr_count(y, x) -> double\n\n    Returns the number of non-null pairs of input values. ``y`` is the dependent\n    value. ``x`` is the independent value.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regr_intercept(y, x) -> double\n\n    Returns linear regression intercept of input values. ``y`` is the dependent\n    value. ``x`` is the independent value.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regr_r2(y, x) -> double\n\n    Returns the coefficient of determination of the linear regression. ``y`` is the dependent\n    value. ``x`` is the independent value. If regr_sxx(y, x) is 0, result is null. If regr_syy(y, x) is 0\n    and regr_sxx(y, x) isn't 0, result is 1.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regr_slope(y, x) -> double\n\n    Returns linear regression slope of input values. ``y`` is the dependent\n    value. ``x`` is the independent value.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regr_sxx(y, x) -> double\n\n    Returns the sum of the squares of the independent values in a group. ``y`` is the dependent\n    value. ``x`` is the independent value.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regr_sxy(y, x) -> double\n\n    Returns the sum of the product of the dependent and independent values in a group. ``y`` is the dependent\n    value. ``x`` is the independent value.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regr_syy(y, x) -> double\n\n    Returns the sum of the squares of the dependent values in a group. ``y`` is the dependent\n    value. ``x`` is the independent value.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    skewness(x) -> double\n\n    Returns the skewness of all input values.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    stddev(x) -> double\n\n    This is an alias for :func:`stddev_samp`.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    stddev_pop(x) -> double\n\n    Returns the population standard deviation of all input values.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    stddev_samp(x) -> double\n\n    Returns the sample standard deviation of all input values.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    variance(x) -> double\n\n    This is an alias for :func:`var_samp`.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    var_pop(x) -> double\n\n    Returns the population variance of all input values.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    var_samp(x) -> double\n\n    Returns the sample variance of all input values.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"miscellaneous",children:"Miscellaneous"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    max_data_size_for_stats(x) -> bigint\n\n    Returns an estimate of the the maximum in-memory size in bytes of ``x``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    sum_data_size_for_stats(x) -> bigint\n\n    Returns an estimate of the sum of in-memory size in bytes of ``x``.\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>o});var t=a(96540);const s={},i=t.createContext(s);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);