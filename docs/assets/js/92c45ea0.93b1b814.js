"use strict";(self.webpackChunkkumo_website=self.webpackChunkkumo_website||[]).push([[29898],{1193:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var i=a(74848),r=a(28453);const s={},t="================\nBinary Functions",o={id:"pollux/functions/presto/binary",title:"binary",description:"================",source:"@site/versioned_docs/version-1.1.1/pollux/functions/presto/binary.mdx",sourceDirName:"pollux/functions/presto",slug:"/pollux/functions/presto/binary",permalink:"/docs/pollux/functions/presto/binary",draft:!1,unlisted:!1,tags:[],version:"1.1.1",lastUpdatedBy:"Jeff lothar",lastUpdatedAt:1748143706e3,frontMatter:{},sidebar:"docs",previous:{title:"array",permalink:"/docs/pollux/functions/presto/array"},next:{title:"Bitwise Functions",permalink:"/docs/pollux/functions/presto/bitwise"}},c={},l=[];function d(n){const e={code:"code",h1:"h1",header:"header",pre:"pre",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"binary-functions",children:"================\nBinary Functions"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    crc32(binary) -> bigint\n\n    Computes the crc32 checksum of ``binary``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    from_base64(string) -> varbinary\n\n    Decodes a Base64-encoded ``string`` back into its original binary form.\n    This function is capable of handling both fully padded and non-padded Base64 encoded strings.\n    Partially padded Base64 strings are not supported and will result in a \"UserError\" status being returned.\n\n    Examples\n    --------\n    Query with padded Base64 string:\n    ::\n        SELECT from_base64('SGVsbG8gV29ybGQ='); -- [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]\n    Query with non-padded Base64 string:\n    ::\n        SELECT from_base64('SGVsbG8gV29ybGQ'); -- [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]\n\n    Query with partial-padded Base64 string:\n    ::\n        SELECT from_base64('SGVsbG8gV29ybGQgZm9yIHZlbG94IQ='); -- UserError: Base64::decode() - invalid input string: string length is not a multiple of 4.\n\n    In the above examples, both the fully padded and non-padded Base64 strings ('SGVsbG8gV29ybGQ=' and 'SGVsbG8gV29ybGQ') decode to the binary representation of the text 'Hello World'.\n    A partial-padded Base64 string 'SGVsbG8gV29ybGQgZm9yIHZlbG94IQ=' will result in a \"UserError\" status indicating the Base64 string is invalid.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    from_base64url(string) -> varbinary\n\n    Decodes ``string`` data from the base64 encoded representation using the `URL safe alphabet <https://www.rfc-editor.org/rfc/rfc4648#section-5>`_ into a varbinary.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    from_big_endian_32(varbinary) -> integer\n\n    Decodes ``integer`` value from a 32-bit 2\u2019s complement big endian ``binary``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    from_big_endian_64(varbinary) -> bigint\n\n    Decodes ``bigint`` value from a 64-bit 2\u2019s complement big endian ``binary``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    from_hex(string) -> varbinary\n\n    Decodes binary data from the hex encoded ``string``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    from_ieee754_32(binary) -> real\n\n    Decodes the 32-bit big-endian ``binary`` in IEEE 754 single-precision floating-point format.\n    Throws a user error if input size is shorter / longer than 32 bits.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    from_ieee754_64(binary) -> double\n\n    Decodes the 64-bit big-endian ``binary`` in IEEE 754 double-precision floating-point format.\n    Throws a user error if input size is shorter / longer than 64 bits.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    hmac_md5(binary, key) -> varbinary\n\n    Computes the HMAC with md5 of ``binary`` with the given ``key``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    hmac_sha1(binary, key) -> varbinary\n\n    Computes the HMAC with sha1 of ``binary`` with the given ``key``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    hmac_sha256(binary, key) -> varbinary\n\n    Computes the HMAC with sha256 of ``binary`` with the given ``key``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    hmac_sha512(binary, key) -> varbinary\n\n    Computes the HMAC with sha512 of ``binary`` with the given ``key``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    length(binary) -> bigint\n\n    Returns the length of ``binary`` in bytes.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    lpad(binary, size, padbinary) -> varbinary\n    :noindex:\n    \n    Left pads ``binary`` to ``size`` bytes with ``padbinary``.\n    If ``size`` is less than the length of ``binary``, the result is\n    truncated to ``size`` characters. ``size`` must not be negative\n    and ``padbinary`` must be non-empty. ``size`` has a maximum value of 1 MiB.\n    In the case of ``size`` being smaller than the length of ``binary``, \n    ``binary`` will be truncated from the right to fit the ``size``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    md5(binary) -> varbinary\n\n    Computes the md5 hash of ``binary``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    rpad(binary, size, padbinary) -> varbinary\n    :noindex:\n\n    Right pads ``binary`` to ``size`` bytes with ``padbinary``.\n    If ``size`` is less than the length of ``binary``, the result is\n    truncated to ``size`` characters. ``size`` must not be negative\n    and ``padbinary`` must be non-empty. ``size`` has a maximum value of 1 MiB.\n    In the case of ``size`` being smaller than the length of ``binary``, \n    ``binary`` will be truncated from the right to fit the ``size``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    sha1(binary) -> varbinary\n\n    Computes the SHA-1 hash of ``binary``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    sha256(binary) -> varbinary\n\n    Computes the SHA-256 hash of ``binary``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    sha512(binary) -> varbinary\n\n    Computes the SHA-512 hash of ``binary``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    spooky_hash_v2_32(binary) -> varbinary\n\n    Computes the SpookyHashV2 32-bit hash of ``binary``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    spooky_hash_v2_64(binary) -> varbinary\n\n    Computes the 64-bit SpookyHashV2 hash of ``binary``.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    to_base64(binary) -> varchar\n\n    Encodes ``binary`` into a base64 string representation.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    to_base64url(binary) -> varchar\n\n    Encodes ``binary`` into a base64 string representation using the `URL safe alphabet <https://www.rfc-editor.org/rfc/rfc4648#section-5>`_.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"   to_big_endian_32(integer) -> varbinary\n\n    Encodes ``integer`` in a 32-bit 2\u2019s complement big endian format.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"   to_big_endian_64(bigint) -> varbinary\n\n    Encodes ``bigint`` in a 64-bit 2\u2019s complement big endian format.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    to_hex(binary) -> varchar\n\n    Encodes ``binary`` into a hex string representation.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    to_ieee754_32(real) -> varbinary\n\n    Encodes ``real`` in a 32-bit big-endian binary according to IEEE 754 single-precision floating-point format.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    to_ieee754_64(double) -> varbinary\n\n    Encodes ``double`` in a 64-bit big-endian binary according to IEEE 754 double-precision floating-point format.\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"    xxhash64(binary) -> varbinary\n\n    Computes the xxhash64 hash of ``binary``.\n"})})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},28453:(n,e,a)=>{a.d(e,{R:()=>t,x:()=>o});var i=a(96540);const r={},s=i.createContext(r);function t(n){const e=i.useContext(s);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:t(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);