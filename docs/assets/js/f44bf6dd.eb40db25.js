"use strict";(self.webpackChunkkumo_website=self.webpackChunkkumo_website||[]).push([[7195],{86790:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>d});var a=s(74848),i=s(28453);const l={},r="Conversion Functions",t={id:"pollux/functions/presto/conversion",title:"Conversion Functions",description:"During expression evaluations, Pollux doesn't implicitly convert expression",source:"@site/versioned_docs/version-1.1.1/pollux/functions/presto/conversion.mdx",sourceDirName:"pollux/functions/presto",slug:"/pollux/functions/presto/conversion",permalink:"/docs/pollux/functions/presto/conversion",draft:!1,unlisted:!1,tags:[],version:"1.1.1",lastUpdatedBy:"Jeff lothar",lastUpdatedAt:1748143706e3,frontMatter:{},sidebar:"docs",previous:{title:"Comparison Functions",permalink:"/docs/pollux/functions/presto/comparison"},next:{title:"IP Functions",permalink:"/docs/pollux/functions/presto/ipaddress"}},c={},d=[{value:"Conversion Functions",id:"conversion-functions-1",level:2},{value:"Supported Conversions",id:"supported-conversions",level:2},{value:"Cast to Integral Types",id:"cast-to-integral-types",level:2},{value:"From integral types",id:"from-integral-types",level:3},{value:"From floating-point types",id:"from-floating-point-types",level:3},{value:"From VARCHAR",id:"from-varchar",level:3},{value:"From decimal",id:"from-decimal",level:3},{value:"Cast to Boolean",id:"cast-to-boolean",level:2},{value:"From integral and floating-point types",id:"from-integral-and-floating-point-types",level:3},{value:"From VARCHAR",id:"from-varchar-1",level:3},{value:"Cast to Floating-Point Types",id:"cast-to-floating-point-types",level:2},{value:"From integral or floating-point types",id:"from-integral-or-floating-point-types",level:3},{value:"From VARCHAR",id:"from-varchar-2",level:3},{value:"From decimal",id:"from-decimal-1",level:3},{value:"Cast to VARCHAR",id:"cast-to-varchar",level:2},{value:"From Floating-Point Types",id:"from-floating-point-types-1",level:3},{value:"From DATE",id:"from-date",level:3},{value:"From TIMESTAMP",id:"from-timestamp",level:3},{value:"From INTERVAL DAY TO SECOND",id:"from-interval-day-to-second",level:3},{value:"From IPADDRESS",id:"from-ipaddress",level:3},{value:"From IPPREFIX",id:"from-ipprefix",level:3},{value:"Cast to TIMESTAMP",id:"cast-to-timestamp",level:2},{value:"From VARCHAR",id:"from-varchar-3",level:3},{value:"From DATE",id:"from-date-1",level:3},{value:"From TIMESTAMP WITH TIME ZONE",id:"from-timestamp-with-time-zone",level:3},{value:"Cast to TIMESTAMP WITH TIME ZONE",id:"cast-to-timestamp-with-time-zone",level:2},{value:"From TIMESTAMP",id:"from-timestamp-1",level:3},{value:"From DATE",id:"from-date-2",level:3},{value:"Cast to Date",id:"cast-to-date",level:2},{value:"From VARCHAR",id:"from-varchar-4",level:3},{value:"From TIMESTAMP",id:"from-timestamp-2",level:3},{value:"Cast to Decimal",id:"cast-to-decimal",level:2},{value:"From boolean type",id:"from-boolean-type",level:3},{value:"From integral types",id:"from-integral-types-1",level:3},{value:"From floating-point types",id:"from-floating-point-types-2",level:3},{value:"From decimal",id:"from-decimal-2",level:3},{value:"From varchar",id:"from-varchar-5",level:3},{value:"Cast to IPADDRESS",id:"cast-to-ipaddress",level:2},{value:"From VARCHAR",id:"from-varchar-6",level:3},{value:"From VARBINARY",id:"from-varbinary",level:3},{value:"From IPPREFIX",id:"from-ipprefix-1",level:3},{value:"Cast to IPPREFIX",id:"cast-to-ipprefix",level:2},{value:"From VARCHAR",id:"from-varchar-7",level:3},{value:"From IPADDRESS",id:"from-ipaddress-1",level:3},{value:"Data Size Functions",id:"data-size-functions",level:2},{value:"Miscellaneous",id:"miscellaneous",level:2}];function o(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"conversion-functions",children:"Conversion Functions"})}),"\n",(0,a.jsx)(n.p,{children:"During expression evaluations, Pollux doesn't implicitly convert expression\narguments to the correct types. If such a conversion is necessary, two provided\nconversion functions can be used explicitly cast values to a particular type."}),"\n",(0,a.jsx)(n.h2,{id:"conversion-functions-1",children:"Conversion Functions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"    cast(value AS type) -> type\n\n    Explicitly cast a value as a type. This can be used to cast a varchar to a\n    numeric value type and vice versa.\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"    try_cast(value AS type) -> type\n\n    Like :func:`cast`, but returns null if the cast fails. ``try_cast(x AS type)``\n    is different from ``try(cast(x AS type))`` in that ``try_cast`` only suppresses\n    errors happening during the casting itself but not those during the evaluation\n    of its argument. For example, ``try_cast(x / 0 as double)`` throws a divide-by-0\n    error, while ``try(cast(x / 0 as double))`` returns a NULL.\n"})}),"\n",(0,a.jsx)(n.h2,{id:"supported-conversions",children:"Supported Conversions"}),"\n",(0,a.jsxs)(n.p,{children:["The supported conversions are listed below, with from-types given at rows and to-types given at columns. Conversions of ARRAY, MAP, and ROW types\nare supported if the conversion of their element types are supported. In addition,\nsupported conversions to/from JSON are listed in :doc:",(0,a.jsx)(n.code,{children:"json"}),"."]}),"\n",(0,a.jsx)(n.p,{children:".. list-table::\n:widths: 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25\n:header-rows: 1"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"tinyint"}),"\n",(0,a.jsx)(n.li,{children:"smallint"}),"\n",(0,a.jsx)(n.li,{children:"integer"}),"\n",(0,a.jsx)(n.li,{children:"bigint"}),"\n",(0,a.jsx)(n.li,{children:"boolean"}),"\n",(0,a.jsx)(n.li,{children:"real"}),"\n",(0,a.jsx)(n.li,{children:"double"}),"\n",(0,a.jsx)(n.li,{children:"varchar"}),"\n",(0,a.jsx)(n.li,{children:"varbinary"}),"\n",(0,a.jsx)(n.li,{children:"timestamp"}),"\n",(0,a.jsx)(n.li,{children:"timestamp with time zone"}),"\n",(0,a.jsx)(n.li,{children:"date"}),"\n",(0,a.jsx)(n.li,{children:"interval day to second"}),"\n",(0,a.jsx)(n.li,{children:"decimal"}),"\n",(0,a.jsx)(n.li,{children:"ipaddress"}),"\n",(0,a.jsx)(n.li,{children:"ipprefix"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"tinyint"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"smallint"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"integer"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"bigint"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"boolean"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"real"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"double"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"varchar"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"varbinary"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"timestamp"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"timestamp with time zone"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"date"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"interval day to second"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"decimal"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"ipaddress"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"ipprefix"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n",(0,a.jsx)(n.li,{children:"Y"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"cast-to-integral-types",children:"Cast to Integral Types"}),"\n",(0,a.jsx)(n.p,{children:"Integral types include bigint, integer, smallint, and tinyint."}),"\n",(0,a.jsx)(n.h3,{id:"from-integral-types",children:"From integral types"}),"\n",(0,a.jsx)(n.p,{children:"Casting one integral type to another is allowed when the input value is within\nthe range of the result type. Casting from invalid input values throws."}),"\n",(0,a.jsx)(n.p,{children:"Valid examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(1234567 as bigint); -- 1234567\n  SELECT cast(12 as tinyint); -- 12\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"\n  SELECT cast(1234 as tinyint); -- Out of range\n  SELECT cast(1234567 as smallint); -- Out of range\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-floating-point-types",children:"From floating-point types"}),"\n",(0,a.jsx)(n.p,{children:"Casting from floating-point input to an integral type rounds the input value to\nthe closest integral value. It is allowed when the rounded result is within the\nrange of the result type. Casting from invalid input values throws."}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"\n  SELECT cast(12345.12 as bigint); -- 12345\n  SELECT cast(12345.67 as bigint); -- 12346\n  SELECT cast(127.1 as tinyint); -- 127\n  SELECT cast(nan() as integer); -- 0\n  SELECT cast(nan() as smallint); -- 0\n  SELECT cast(nan() as tinyint); -- 0\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(127.8 as tinyint); -- Out of range\n  SELECT cast(1234567.89 as smallint); -- Out of range\n  SELECT cast(infinity() as bigint); -- Out of range\n"})}),"\n",(0,a.jsx)(n.p,{children:"Casting NaN to bigint returns 0 in Pollux but throws in Presto. We keep the\nbehavior of Pollux by intention because this is more consistent with other\nsupported cases."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(nan() as bigint); -- 0\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-varchar",children:"From VARCHAR"}),"\n",(0,a.jsx)(n.p,{children:"Casting a string to an integral type is allowed if the string represents an\nintegral number within the range of the result type. By default, casting from\nstrings that represent floating-point numbers is not allowed.\nCasting from invalid input values throws."}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast('12345' as bigint); -- 12345\n  SELECT cast('+1' as tinyint); -- 1\n  SELECT cast('-1' as tinyint); -- -1\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast('12345.67' as tinyint); -- Invalid argument\n  SELECT cast('12345.67' as bigint); -- Invalid argument\n  SELECT cast('1.2' as tinyint); -- Invalid argument\n  SELECT cast('-1.8' as tinyint); -- Invalid argument\n  SELECT cast('1.' as tinyint); -- Invalid argument\n  SELECT cast('-1.' as tinyint); -- Invalid argument\n  SELECT cast('0.' as tinyint); -- Invalid argument\n  SELECT cast('.' as tinyint); -- Invalid argument\n  SELECT cast('-.' as tinyint); -- Invalid argument\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-decimal",children:"From decimal"}),"\n",(0,a.jsx)(n.p,{children:"The decimal part is rounded."}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(2.56 decimal(6, 2) as integer); -- 3\n  SELECT cast(3.46 decimal(6, 2) as integer); -- 3\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(214748364890 decimal(12, 2) as integer); -- Out of range\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cast-to-boolean",children:"Cast to Boolean"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"from-integral-and-floating-point-types",children:"From integral and floating-point types"}),"\n",(0,a.jsxs)(n.p,{children:["Casting from integral or floating-point numbers to boolean is allowed. Non-zero\nnumbers are converted to ",(0,a.jsx)(n.code,{children:"true"})," while zero is converted to ",(0,a.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(1 as boolean); -- true\n  SELECT cast(0 as boolean); -- false\n  SELECT cast(12 as boolean); -- true\n  SELECT cast(-1 as boolean); -- true\n  SELECT cast(1.0 as boolean); -- true\n  SELECT cast(1.1 as boolean); -- true\n  SELECT cast(-1.1 as boolean); -- true\n  SELECT cast(nan() as boolean); -- true\n  SELECT cast(infinity() as boolean); -- true\n  SELECT cast(0.0000000000001 as boolean); -- true\n  SELECT cast(0.5 as boolean); -- true\n  SELECT cast(-0.5 as boolean); -- true\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-varchar-1",children:"From VARCHAR"}),"\n",(0,a.jsxs)(n.p,{children:["The strings ",(0,a.jsx)(n.code,{children:"t, f, 1, 0, true, false"})," and their upper case equivalents are allowed to be casted to boolean.\nCasting from other strings to boolean throws."]}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"\n  SELECT cast('1' as boolean); -- true\n  SELECT cast('0' as boolean); -- false\n  SELECT cast('t' as boolean); -- true (case insensitive)\n  SELECT cast('true' as boolean); -- true (case insensitive)\n  SELECT cast('f' as boolean); -- false (case insensitive)\n  SELECT cast('false' as boolean); -- false (case insensitive)\n  SELECT cast('F' as boolean); -- false (case insensitive)\n  SELECT cast('T' as boolean); -- true (case insensitive)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast('1.7E308' as boolean); -- Invalid argument\n  SELECT cast('nan' as boolean); -- Invalid argument\n  SELECT cast('infinity' as boolean); -- Invalid argument\n  SELECT cast('12' as boolean); -- Invalid argument\n  SELECT cast('-1' as boolean); -- Invalid argument\n  SELECT cast('tr' as boolean); -- Invalid argument\n  SELECT cast('tru' as boolean); -- Invalid argument\n  SELECT cast('No' as boolean); -- Invalid argument\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cast-to-floating-point-types",children:"Cast to Floating-Point Types"}),"\n",(0,a.jsx)(n.h3,{id:"from-integral-or-floating-point-types",children:"From integral or floating-point types"}),"\n",(0,a.jsx)(n.p,{children:"Casting from an integral or floating-point number is allowed."}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(1 as real); -- 1.0\n  SELECT cast(123.45 as real); -- 123.45\n"})}),"\n",(0,a.jsxs)(n.p,{children:["There are two cases where Pollux behaves differently from Presto (:issue:",(0,a.jsx)(n.code,{children:"5934"}),") when casting\nto real from a value beyond real's limit. We will fix them to follow Presto's\nbehavior."]}),"\n",(0,a.jsx)(n.p,{children:"::"}),"\n",(0,a.jsx)(n.p,{children:"SELECT cast(1.7E308 as real); -- Presto returns Infinity but Pollux throws\nSELECT cast(-1.7E308 as real); -- Presto returns -Infinity but Pollux throws"}),"\n",(0,a.jsx)(n.h3,{id:"from-varchar-2",children:"From VARCHAR"}),"\n",(0,a.jsx)(n.p,{children:"Casting a string to real is allowed if the string represents an integral or\nfloating-point number. Casting from invalid input values throws."}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast('1.' as real); -- 1.0\n  SELECT cast('1' as real); -- 1.0\n  SELECT cast('1.7E308' as real); -- Infinity\n  SELECT cast('Infinity' as real); -- Infinity (case sensitive)\n  SELECT cast('-Infinity' as real); -- -Infinity (case sensitive)\n  SELECT cast('NaN' as real); -- NaN (case sensitive)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast('1.2a' as real); -- Invalid argument\n  SELECT cast('1.2.3' as real); -- Invalid argument\n  SELECT cast('infinity' as real); -- Invalid argument\n  SELECT cast('-infinity' as real); -- -Invalid argument\n  SELECT cast('inf' as real); -- Invalid argument\n  SELECT cast('InfiNiTy' as real); -- Invalid argument\n  SELECT cast('INFINITY' as real); -- Invalid argument\n  SELECT cast('nAn' as real); -- Invalid argument\n  SELECT cast('nan' as real); -- Invalid argument\n``\nBelow cases are supported in Presto, but throw in Pollux.\n\n```sql\n\n  SELECT cast('1.2f' as real); -- 1.2\n  SELECT cast('1.2f' as double); -- 1.2\n  SELECT cast('1.2d' as real); -- 1.2\n  SELECT cast('1.2d' as double); -- 1.2\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-decimal-1",children:"From decimal"}),"\n",(0,a.jsx)(n.p,{children:"Casting from decimal to double, float or any integral type is allowed. During decimal to an integral type conversion, if result overflows, or underflows, an exception is thrown."}),"\n",(0,a.jsx)(n.p,{children:"Valid example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(decimal '10.001' as double); -- 10.001\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(decimal '300.001' as tinyint); -- Out of range\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cast-to-varchar",children:"Cast to VARCHAR"}),"\n",(0,a.jsx)(n.p,{children:"Casting from scalar types to string is allowed."}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(123 as varchar); -- '123'\n  SELECT cast(123.45 as varchar); -- '123.45'\n  SELECT cast(123.0 as varchar); -- '123.0'\n  SELECT cast(nan() as varchar); -- 'NaN'\n  SELECT cast(infinity() as varchar); -- 'Infinity'\n  SELECT cast(true as varchar); -- 'true'\n  SELECT cast(timestamp '1970-01-01 00:00:00' as varchar); -- '1970-01-01 00:00:00.000'\n  SELECT cast(timestamp '2024-06-01 11:37:15.123 America/New_York' as varchar); -- '2024-06-01 11:37:15.123 America/New_York'\n  SELECT cast(cast(22.51 as DECIMAL(5, 3)) as varchar); -- '22.510'\n  SELECT cast(cast(-22.51 as DECIMAL(4, 2)) as varchar); -- '-22.51'\n  SELECT cast(cast(0.123 as DECIMAL(3, 3)) as varchar); -- '0.123'\n  SELECT cast(cast(1 as DECIMAL(6, 2)) as varchar); -- '1.00'\n  SELECT cast(cast(0 as DECIMAL(6, 2)) as varchar); -- '0.00'\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-floating-point-types-1",children:"From Floating-Point Types"}),"\n",(0,a.jsxs)(n.p,{children:["By default, casting a real or double to string returns standard notation if the magnitude of input value is greater than\nor equal to 10 :superscript:",(0,a.jsx)(n.code,{children:"-3"})," but less than 10 :superscript:",(0,a.jsx)(n.code,{children:"7"}),", and returns scientific notation otherwise."]}),"\n",(0,a.jsx)(n.p,{children:"Positive zero returns '0.0' and negative zero returns '-0.0'. Positive infinity returns 'Infinity' and negative infinity\nreturns '-Infinity'. Positive and negative NaN returns 'NaN'."}),"\n",(0,a.jsx)(n.p,{children:"If legacy_cast configuration property is true, the result is standard notation for all input value."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Valid examples if legacy_cast = false"}),","]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"\n  SELECT cast(double '123456789.01234567' as varchar); -- '1.2345678901234567E8'\n  SELECT cast(double '10000000.0' as varchar); -- '1.0E7'\n  SELECT cast(double '12345.0' as varchar); -- '12345.0'\n  SELECT cast(double '-0.001' as varchar); -- '-0.001'\n  SELECT cast(double '-0.00012' as varchar); -- '-1.2E-4'\n  SELECT cast(double '0.0' as varchar); -- '0.0'\n  SELECT cast(double '-0.0' as varchar); -- '-0.0'\n  SELECT cast(infinity() as varchar); -- 'Infinity'\n  SELECT cast(-infinity() as varchar); -- '-Infinity'\n  SELECT cast(nan() as varchar); -- 'NaN'\n  SELECT cast(-nan() as varchar); -- 'NaN'\n\n  SELECT cast(real '123456780.0' as varchar); -- '1.2345678E8'\n  SELECT cast(real '10000000.0' as varchar); -- '1.0E7'\n  SELECT cast(real '12345.0' as varchar); -- '12345.0'\n  SELECT cast(real '-0.001' as varchar); -- '-0.001'\n  SELECT cast(real '-0.00012' as varchar); -- '-1.2E-4'\n  SELECT cast(real '0.0' as varchar); -- '0.0'\n  SELECT cast(real '-0.0' as varchar); -- '-0.0'\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Valid examples if legacy_cast = true"}),","]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"\n  SELECT cast(double '123456789.01234567' as varchar); -- '123456789.01234567'\n  SELECT cast(double '10000000.0' as varchar); -- '10000000.0'\n  SELECT cast(double '-0.001' as varchar); -- '-0.001'\n  SELECT cast(double '-0.00012' as varchar); -- '-0.00012'\n\n  SELECT cast(real '123456780.0' as varchar); -- '123456784.0'\n  SELECT cast(real '10000000.0' as varchar); -- '10000000.0'\n  SELECT cast(real '12345.0' as varchar); -- '12345.0'\n  SELECT cast(real '-0.00012' as varchar); -- '-0.00011999999696854502'\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-date",children:"From DATE"}),"\n",(0,a.jsx)(n.p,{children:"Casting DATE to VARCHAR returns an ISO-8601 formatted string: YYYY-MM-DD."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"\n    SELECT cast(date('2024-03-14') as varchar); -- '2024-03-14'\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-timestamp",children:"From TIMESTAMP"}),"\n",(0,a.jsx)(n.p,{children:"By default, casting a timestamp to a string returns ISO 8601 format with space as separator\nbetween date and time, and the year part is padded with zeros to 4 characters."}),"\n",(0,a.jsx)(n.p,{children:"If legacy_cast configuration property is true, the result string uses character 'T'\nas separator between date and time and the year part is not padded."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Valid examples if legacy_cast = false"}),","]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(timestamp '1970-01-01 00:00:00' as varchar); -- '1970-01-01 00:00:00.000'\n  SELECT cast(timestamp '2000-01-01 12:21:56.129' as varchar); -- '2000-01-01 12:21:56.129'\n  SELECT cast(timestamp '384-01-01 08:00:00.000' as varchar); -- '0384-01-01 08:00:00.000'\n  SELECT cast(timestamp '10000-02-01 16:00:00.000' as varchar); -- '10000-02-01 16:00:00.000'\n  SELECT cast(timestamp '-10-02-01 10:00:00.000' as varchar); -- '-0010-02-01 10:00:00.000'\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Valid examples if legacy_cast = true"}),","]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"\n  SELECT cast(timestamp '1970-01-01 00:00:00' as varchar); -- '1970-01-01T00:00:00.000'\n  SELECT cast(timestamp '2000-01-01 12:21:56.129' as varchar); -- '2000-01-01T12:21:56.129'\n  SELECT cast(timestamp '384-01-01 08:00:00.000' as varchar); -- '384-01-01T08:00:00.000'\n  SELECT cast(timestamp '-10-02-01 10:00:00.000' as varchar); -- '-10-02-01T10:00:00.000'\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-interval-day-to-second",children:"From INTERVAL DAY TO SECOND"}),"\n",(0,a.jsxs)(n.p,{children:["Casting INTERVAL DAY TO SECOND to VARCHAR returns a string formatted as\n'[sign]D HH:MM",":SS",".ZZZ', where 'sign' is an optional '-' sign if interval is negative, D\nis the number of whole days in the interval, HH is then number of hours between 00 and\n24, MM is the number of minutes between 00 and 59, SS is the number of seconds between\n00 and 59, and zzz is the number of milliseconds between 000 and 999."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"    SELECT cast(interval '1' day as varchar); -- '1 00:00:00.000'\n    SELECT cast(interval '123456' second as varchar); -- '1 10:17:36.000'\n    SELECT cast(now() - date('2024-03-01') as varchar); -- '35 09:15:54.092'\n    SELECT cast(date('2024-03-01') - now() as varchar); -- '-35 09:16:20.598'\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-ipaddress",children:"From IPADDRESS"}),"\n",(0,a.jsxs)(n.p,{children:["Casting from IPADDRESS to VARCHAR returns a string formatted as x.x.x.x for IPV4 formatted IPV6 addresses.\nFor all other IPV6 addresses it will be formatted in compressed alternate form IPV6 defined in ",(0,a.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/rfc4291.html#section-2.2",children:"RFC 4291#section-2.2"})]}),"\n",(0,a.jsx)(n.p,{children:"IPV4:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(ipaddress '1.2.3.4' as varchar); -- '1.2.3.4'\n"})}),"\n",(0,a.jsx)(n.p,{children:"IPV6:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(ipaddress '2001:0db8:0000:0000:0000:ff00:0042:8329' as varchar); -- '2001:db8::ff00:42:8329'\n  SELECT cast(ipaddress '0:0:0:0:0:0:13.1.68.3' as varchar); -- '::13.1.68.3'\n"})}),"\n",(0,a.jsx)(n.p,{children:"IPV4 mapped IPV6:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(ipaddress '::ffff:ffff:ffff' as varchar); -- '255.255.255.255'\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-ipprefix",children:"From IPPREFIX"}),"\n",(0,a.jsxs)(n.p,{children:["Casting from IPPREFIX to VARCHAR returns a string formatted as ",(0,a.jsxs)(n.em,{children:["x.x.x.x/",(0,a.jsx)(n.code,{children:"<prefix-length>"})]})," for IPv4 formatted IPv6 addresses."]}),"\n",(0,a.jsxs)(n.p,{children:["For all other IPv6 addresses it will be formatted in compressed alternate form IPv6 defined in ",(0,a.jsx)(n.code,{children:"RFC 4291#section-2.2 <https://datatracker.ietf.org/doc/html/rfc4291.html#section-2.2>"}),"_\nfollowed by ",(0,a.jsx)(n.em,{children:(0,a.jsx)(n.code,{children:"<prefix-length>"})}),". ",(0,a.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/rfc4291.html#section-2.3",children:(0,a.jsx)(n.code,{children:"RFC 4291#section-2.3"})})]}),"\n",(0,a.jsx)(n.p,{children:"IPv4:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(ipprefix '1.2.0.0/16' as varchar); -- '1.2.0.0/16'\n"})}),"\n",(0,a.jsx)(n.p,{children:"IPv6:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(ipprefix '2001:db8::ff00:42:8329/128' as varchar); -- '2001:db8::ff00:42:8329/128'\n  SELECT cast(ipprefix '0:0:0:0:0:0:13.1.68.3/32' as varchar); -- '::/32'\n"})}),"\n",(0,a.jsx)(n.p,{children:"IPv4 mapped IPv6:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(ipaddress '::ffff:ffff:0000/16' as varchar); -- '255.255.0.0/16'\n``\n### Cast to VARBINARY\n\n\n### From IPADDRESS\n\n\nReturns the IPV6 address as a 16 byte varbinary string in network byte order.\n\nInternally, the type is a pure IPv6 address. Support for IPv4 is handled using the IPv4-mapped IPv6 address range `(RFC 4291#section-2.5.5.2) <https://datatracker.ietf.org/doc/html/rfc4291.html#section-2.5.5.2>`_.\nWhen creating an IPADDRESS, IPv4 addresses will be mapped into that range.\n\nIPV6:\n\n```sql\n\n  SELECT cast(ipaddress '2001:0db8:0000:0000:0000:ff00:0042:8329' as varbinary); -- 0x20010db8000000000000ff0000428329\n"})}),"\n",(0,a.jsx)(n.p,{children:"IPV4:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast('1.2.3.4' as ipaddress); -- 0x00000000000000000000ffff01020304\n"})}),"\n",(0,a.jsx)(n.p,{children:"IPV4 mapped IPV6:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast('::ffff:ffff:ffff' as ipaddress); -- 0x00000000000000000000ffffffffffff\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cast-to-timestamp",children:"Cast to TIMESTAMP"}),"\n",(0,a.jsx)(n.h3,{id:"from-varchar-3",children:"From VARCHAR"}),"\n",(0,a.jsxs)(n.p,{children:["Casting from a string to timestamp is allowed if the string represents a\ntimestamp in the format ",(0,a.jsx)(n.code,{children:"YYYY-MM-DD"})," followed by an optional ",(0,a.jsx)(n.code,{children:"hh:mm:ss.MS"}),".\nSeconds and milliseconds are optional. Casting from invalid input values throws."]}),"\n",(0,a.jsx)(n.p,{children:"Valid examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast('1970-01-01' as timestamp); -- 1970-01-01 00:00:00\n  SELECT cast('1970-01-01 00:00:00.123' as timestamp); -- 1970-01-01 00:00:00.123\n  SELECT cast('1970-01-01 02:01' as timestamp); -- 1970-01-01 02:01:00\n  SELECT cast('1970-01-01 00:00:00-02:00' as timestamp); -- 1970-01-01 02:00:00\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast('2012-Oct-23' as timestamp); -- Invalid argument\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Optionally, strings may also contain timezone information at the end. Timezone\ninformation may be offsets in the format ",(0,a.jsx)(n.code,{children:"+01:00"})," or ",(0,a.jsx)(n.code,{children:"-02:00"}),", for example, or\ntimezone names, like ",(0,a.jsx)(n.code,{children:"UTC"}),", ",(0,a.jsx)(n.code,{children:"Z"}),", ",(0,a.jsx)(n.code,{children:"America/Los_Angeles"})," and others,\n",(0,a.jsx)(n.code,{children:"as defined here <https://github.com/facebookincubator/pollux/blob/main/pollux/type/tz/TimeZoneDatabase.cpp>"}),"_."]}),"\n",(0,a.jsx)(n.p,{children:"For example, these strings contain valid timezone information:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"\n  SELECT cast('1970-01-01 00:00:00 +09:00' as timestamp);\n  SELECT cast('1970-01-01 00:00:00 UTC' as timestamp);\n  SELECT cast('1970-01-01 00:00:00 America/Sao_Paulo' as timestamp);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If timezone information is specified in the string, the returned timestamp\nis adjusted to the corresponding timezone. Otherwise, the timestamp is\nassumed to be in the client session timezone, and adjusted accordingly\nbased on the value of ",(0,a.jsx)(n.code,{children:"adjust_timestamp_to_session_timezone"}),", as described below."]}),"\n",(0,a.jsx)(n.p,{children:"The space between the hour and timezone definition is optional."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast('1970-01-01 00:00 Z' as timestamp);\n  SELECT cast('1970-01-01 00:00Z' as timestamp);\n"})}),"\n",(0,a.jsx)(n.p,{children:"Are both valid."}),"\n",(0,a.jsx)(n.h3,{id:"from-date-1",children:"From DATE"}),"\n",(0,a.jsx)(n.p,{children:"Casting from date to timestamp is allowed."}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(date '1970-01-01' as timestamp); -- 1970-01-01 00:00:00\n  SELECT cast(date '2012-03-09' as timestamp); -- 2012-03-09 00:00:00\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-timestamp-with-time-zone",children:"From TIMESTAMP WITH TIME ZONE"}),"\n",(0,a.jsxs)(n.p,{children:["The results depend on whether configuration property ",(0,a.jsx)(n.code,{children:"adjust_timestamp_to_session_timezone"})," is set or not."]}),"\n",(0,a.jsx)(n.p,{children:'If set to true, input timezone is ignored and timestamp is returned as is. For example,\n"1970-01-01 00:00:00.000 America/Los_Angeles" becomes "1970-01-01 08:00:00.000".'}),"\n",(0,a.jsx)(n.p,{children:'Otherwise, timestamp is shifted by the offset of the timezone. For example,\n"1970-01-01 00:00:00.000 America/Los_Angeles" becomes "1970-01-01 00:00:00.000".'}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  -- `adjust_timestamp_to_session_timezone` is true\n  SELECT to_unixtime(cast(timestamp '1970-01-01 00:00:00 America/Los_Angeles' as timestamp)); -- 28800.0 (1970-01-01 08:00:00.000)\n  SELECT to_unixtime(cast(timestamp '2012-03-09 10:00:00 Asia/Chongqing' as timestamp)); -- 1.3312584E9 (2012-03-09 02:00:00.000)\n  SELECT to_unixtime(cast(from_unixtime(0, '+06:00') as timestamp)); -- 0.0 (1970-01-01 00:00:00.000)\n  SELECT to_unixtime(cast(from_unixtime(0, '-02:00') as timestamp)); -- 0.0 (1970-01-01 00:00:00.000)\n\n  -- `adjust_timestamp_to_session_timezone` is false\n  SELECT to_unixtime(cast(timestamp '1970-01-01 00:00:00 America/Los_Angeles' as timestamp)); -- 0.0 (1970-01-01 00:00:00.000)\n  SELECT to_unixtime(cast(timestamp '2012-03-09 10:00:00 Asia/Chongqing' as timestamp)); -- 1.3312872E9 (2012-03-09 10:00:00.000)\n  SELECT to_unixtime(cast(from_unixtime(0, '+06:00') as timestamp)); -- 21600.0 (1970-01-01 06:00:00.000)\n  SELECT to_unixtime(cast(from_unixtime(0, '-02:00') as timestamp)); -- -7200.0 (1969-12-31 22:00:00.000)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cast-to-timestamp-with-time-zone",children:"Cast to TIMESTAMP WITH TIME ZONE"}),"\n",(0,a.jsx)(n.h3,{id:"from-timestamp-1",children:"From TIMESTAMP"}),"\n",(0,a.jsxs)(n.p,{children:["The results depend on whether configuration property ",(0,a.jsx)(n.code,{children:"adjust_timestamp_to_session_timezone"})," is set or not."]}),"\n",(0,a.jsxs)(n.p,{children:["If set to true, the output is adjusted to be equivalent as the input timestamp in UTC\nbased on the user provided ",(0,a.jsx)(n.code,{children:"session_timezone"}),' (if any). For example, when user supplies\n"America/Los_Angeles" "1970-01-01 00:00:00.000" becomes "1969-12-31 16:00:00.000 America/Los_Angeles".']}),"\n",(0,a.jsxs)(n.p,{children:["Otherwise, the user provided ",(0,a.jsx)(n.code,{children:"session_timezone"}),' (if any) is simply appended to the input\ntimestamp. For example, "1970-01-01 00:00:00.000" becomes "1970-01-01 00:00:00.000 America/Los_Angeles".']}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  -- `adjust_timestamp_to_session_timezone` is true\n  SELECT cast(timestamp '1970-01-01 00:00:00' as timestamp with time zone); -- 1969-12-31 16:00:00.000 America/Los_Angeles\n  SELECT cast(timestamp '2012-03-09 10:00:00' as timestamp with time zone); -- 2012-03-09 02:00:00.000 America/Los_Angeles\n  SELECT cast(from_unixtime(0) as timestamp with time zone); -- 1969-12-31 16:00:00.000 America/Los_Angeles\n\n  -- `adjust_timestamp_to_session_timezone` is false\n  SELECT cast(timestamp '1970-01-01 00:00:00' as timestamp with time zone); -- 1970-01-01 00:00:00.000 America/Los_Angeles\n  SELECT cast(timestamp '2012-03-09 10:00:00' as timestamp with time zone); -- 2012-03-09 10:00:00.000 America/Los_Angeles\n  SELECT cast(from_unixtime(0) as timestamp with time zone); -- 1970-01-01 00:00:00.000 America/Los_Angeles\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-date-2",children:"From DATE"}),"\n",(0,a.jsxs)(n.p,{children:["The results depend on ",(0,a.jsx)(n.code,{children:"session_timestamp"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"    -- session_timezone = America/Los_Angeles\n    SELECT cast(date '2024-06-01' as timestamp with time zone); -- 2024-06-01 00:00:00.000 America/Los_Angeles\n\n    -- session_timezone = Asia/Shanghai\n    SELECT cast(date '2024-06-01' as timestamp with time zone); -- 2024-06-01 00:00:00.000 Asia/Shanghai\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cast-to-date",children:"Cast to Date"}),"\n",(0,a.jsx)(n.h3,{id:"from-varchar-4",children:"From VARCHAR"}),"\n",(0,a.jsxs)(n.p,{children:["Only ISO 8601 strings are supported: ",(0,a.jsx)(n.code,{children:"[+-]YYYY-MM-DD"}),". Casting from invalid input values throws."]}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.p,{children:"::"}),"\n",(0,a.jsx)(n.p,{children:"SELECT cast('1970-01-01' as date); -- 1970-01-01"}),"\n",(0,a.jsx)(n.p,{children:"Invalid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"\n  SELECT cast('2012' as date); -- Invalid argument\n  SELECT cast('2012-10' as date); -- Invalid argument\n  SELECT cast('2012-10-23T123' as date); -- Invalid argument\n  SELECT cast('2012-10-23 (BC)' as date); -- Invalid argument\n  SELECT cast('2012-Oct-23' as date); -- Invalid argument\n  SELECT cast('2012/10/23' as date); -- Invalid argument\n  SELECT cast('2012.10.23' as date); -- Invalid argument\n  SELECT cast('2012-10-23 ' as date); -- Invalid argument\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-timestamp-2",children:"From TIMESTAMP"}),"\n",(0,a.jsxs)(n.p,{children:["Casting from timestamp to date is allowed. If present, the part of ",(0,a.jsx)(n.code,{children:"hh:mm:ss"}),"\nin the input is ignored."]}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(timestamp '1970-01-01 00:00:00' as date); -- 1970-01-01\n  SELECT cast(timestamp '1970-01-01 23:59:59' as date); -- 1970-01-01\n"})}),"\n",(0,a.jsx)(n.p,{children:"From TIMESTAMP WITH TIME ZONE\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}),"\n",(0,a.jsxs)(n.p,{children:["Casting from TIMESTAMP WITH TIME ZONE to DATE is allowed. If present,\nthe part of ",(0,a.jsx)(n.code,{children:"hh:mm:ss"})," in the input is ignored."]}),"\n",(0,a.jsx)(n.p,{children:"Session time zone does not affect the result."}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT CAST(timestamp '2024-06-01 01:38:00 America/New_York' as DATE); -- 2024-06-01\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cast-to-decimal",children:"Cast to Decimal"}),"\n",(0,a.jsx)(n.h3,{id:"from-boolean-type",children:"From boolean type"}),"\n",(0,a.jsx)(n.p,{children:"Casting a boolean number to decimal of given precision and scale is allowed.\nTrue value is converted to 1 and false to 0."}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(true as decimal(4, 2)); -- decimal '1.00'\n  SELECT cast(false as decimal(8, 2)); -- decimal '0'\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-integral-types-1",children:"From integral types"}),"\n",(0,a.jsx)(n.p,{children:"Casting an integral number to a decimal of given precision and scale is allowed\nif the input value can be represented by the precision and scale. Casting from\ninvalid input values throws."}),"\n",(0,a.jsx)(n.p,{children:"Valid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(1 as decimal(4, 2)); -- decimal '1.00'\n  SELECT cast(10 as decimal(4, 2)); -- decimal '10.00'\n  SELECT cast(123 as decimal(5, 2)); -- decimal '123.00'\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(123 as decimal(6, 4)); -- Out of range\n  SELECT cast(123 as decimal(4, 2)); -- Out of range\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-floating-point-types-2",children:"From floating-point types"}),"\n",(0,a.jsx)(n.p,{children:"Casting a floating-point number to a decimal of given precision and scale is allowed\nif the input value can be represented by the precision and scale. When the given\nscale is less than the number of decimal places, the floating-point value is rounded.\nThe conversion precision is up to 15 for double and 6 for real according to the\nsignificant decimal digits precision they provide. Casting from NaN or infinite value\nthrows."}),"\n",(0,a.jsx)(n.p,{children:"Valid example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(0.12 as decimal(4, 4)); -- decimal '0.1200'\n  SELECT cast(0.12 as decimal(4, 1)); -- decimal '0.1'\n  SELECT cast(0.19 as decimal(4, 1)); -- decimal '0.2'\n  SELECT cast(0.123456789123123 as decimal(38, 18)); -- decimal '0.123456789123123000'\n  SELECT cast(real '0.123456' as decimal(38, 18)); -- decimal '0.123456000000000000'\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(123.12 as decimal(6, 4)); -- Out of range\n  SELECT cast(99999.99 as decimal(6, 2)); -- Out of range\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-decimal-2",children:"From decimal"}),"\n",(0,a.jsx)(n.p,{children:"Casting one decimal to another is allowed if the input value can be represented\nby the result decimal type. When casting from a larger scale to a smaller one,\nthe fraction part is rounded."}),"\n",(0,a.jsx)(n.p,{children:"Valid example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(decimal '0.69' as decimal(4, 3)); -- decimal '0.690'\n  SELECT cast(decimal '0.69' as decimal(4, 1)); -- decimal '0.7'\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(decimal '-1000.000' as decimal(6, 4)); -- Out of range\n  SELECT cast(decimal '123456789' as decimal(9, 1)); -- Out of range\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-varchar-5",children:"From varchar"}),"\n",(0,a.jsx)(n.p,{children:"Casting varchar to a decimal of given precision and scale is allowed\nif the input value can be represented by the precision and scale. When casting from\na larger scale to a smaller one, the fraction part is rounded. Casting from invalid input value throws."}),"\n",(0,a.jsx)(n.p,{children:"Valid example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"\n  SELECT cast('9999999999.99' as decimal(12, 2)); -- decimal '9999999999.99'\n  SELECT cast('1.556' as decimal(12, 2)); -- decimal '1.56'\n  SELECT cast('1.554' as decimal(12, 2)); -- decimal '1.55'\n  SELECT cast('-1.554' as decimal(12, 2)); -- decimal '-1.55'\n  SELECT cast('+09' as decimal(12, 2)); -- decimal '9.00'\n  SELECT cast('9.' as decimal(12, 2)); -- decimal '9.00'\n  SELECT cast('.9' as decimal(12, 2)); -- decimal '0.90'\n  SELECT cast('3E+2' as decimal(12, 2)); -- decimal '300.00'\n  SELECT cast('3E+00002' as decimal(12, 2)); -- decimal '300.00'\n  SELECT cast('3e+2' as decimal(12, 2)); -- decimal '300.00'\n  SELECT cast('31.423e+2' as decimal(12, 2)); -- decimal '3142.30'\n  SELECT cast('1.2e-2' as decimal(12, 2)); -- decimal '0.01'\n  SELECT cast('1.2e-5' as decimal(12, 2)); -- decimal '0.00'\n  SELECT cast('0000.123' as decimal(12, 2)); -- decimal '0.12'\n  SELECT cast('.123000000' as decimal(12, 2)); -- decimal '0.12'\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast('1.23e67' as decimal(38, 0)); -- Value too large\n  SELECT cast('0.0446a' as decimal(9, 1)); -- Value is not a number\n  SELECT cast('' as decimal(9, 1)); -- Value is not a number\n  SELECT cast('23e-5d' as decimal(9, 1)); -- Value is not a number\n  SELECT cast('1.23 ' as decimal(38, 0)); -- Value is not a number\n  SELECT cast(' -3E+2' as decimal(12, 2)); -- Value is not a number\n  SELECT cast('-3E+2.1' as decimal(12, 2)); -- Value is not a number\n  SELECT cast('3E+' as decimal(12, 2)); -- Value is not a number\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cast-to-ipaddress",children:"Cast to IPADDRESS"}),"\n",(0,a.jsx)(n.p,{children:".. _ipaddress-from-varchar:"}),"\n",(0,a.jsx)(n.h3,{id:"from-varchar-6",children:"From VARCHAR"}),"\n",(0,a.jsx)(n.p,{children:"To cast a varchar to IPAddress input string must be in the form of either\nIPV4 or IPV6."}),"\n",(0,a.jsx)(n.p,{children:"For IPV4 it must be in the form of:\nx.x.x.x where each x is an integer value between 0-255."}),"\n",(0,a.jsxs)(n.p,{children:["For IPV6 it must follow any of the forms defined in ",(0,a.jsx)(n.code,{children:"RFC 4291#section-2.2 <https://datatracker.ietf.org/doc/html/rfc4291.html#section-2.2>"}),"_."]}),"\n",(0,a.jsx)(n.p,{children:"Full form:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"   2001:0DB8:0000:0000:0008:0800:200C:417A\n   2001:DB8:0:0:8:800:200C:417A\n"})}),"\n",(0,a.jsx)(n.p,{children:"Compressed form:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"  2001:DB8::8:800:200C:417A\n"})}),"\n",(0,a.jsx)(n.p,{children:"Alternate form:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"  0:0:0:0:0:0:13.1.68.3\n  ::13.1.68.3\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Internally, the type is a pure IPv6 address. Support for IPv4 is handled using the IPv4-mapped IPv6 address range ",(0,a.jsx)(n.code,{children:"(RFC 4291#section-2.5.5.2) <https://datatracker.ietf.org/doc/html/rfc4291.html#section-2.5.5.2>"}),"_.\nWhen creating an IPADDRESS, IPv4 addresses will be mapped into that range."]}),"\n",(0,a.jsxs)(n.p,{children:["When formatting an IPADDRESS, any address within the mapped range will be formatted as an IPv4 address.\nOther addresses will be formatted as IPv6 using the canonical format defined in ",(0,a.jsx)(n.code,{children:"RFC 5952 <https://datatracker.ietf.org/doc/html/rfc5952.html>"}),"_."]}),"\n",(0,a.jsx)(n.p,{children:"Valid examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast('2001:0db8:0000:0000:0000:ff00:0042:8329' as ipaddress); -- ipaddress '2001:db8::ff00:42:8329'\n  SELECT cast('1.2.3.4' as ipaddress); -- ipaddress '1.2.3.4'\n  SELECT cast('::ffff:ffff:ffff' as ipaddress); -- ipaddress '255.255.255.255'\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid examples:"}),"\n",(0,a.jsx)(n.p,{children:"``"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast('2001:db8::1::1' as ipaddress); -- Invalid IP address '2001:db8::1::1'\n  SELECT cast('789.1.1.1' as ipaddress); -- Invalid IP address '789.1.1.1'\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-varbinary",children:"From VARBINARY"}),"\n",(0,a.jsx)(n.p,{children:"To cast a varbinary to IPAddress it must be either IPV4(4 Bytes)\nor IPV6(16 Bytes) in network byte order."}),"\n",(0,a.jsx)(n.p,{children:"IPV4:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"[01, 02, 03, 04] -> 1.2.3.4\n"})}),"\n",(0,a.jsx)(n.p,{children:"IPV6:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"[0x20, 0x01, 0x0d, 0xb8 0x00, 0x00, 0x00, 0x00 0x00 0x00, 0xff, 0x00, 0x00, 0x42, 0x83, 0x29] -> 2001:db8::ff00:42:8329\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Internally, the type is a pure IPv6 address. Support for IPv4 is handled using the IPv4-mapped IPv6 address range ",(0,a.jsx)(n.code,{children:"(RFC 4291#section-2.5.5.2) <https://datatracker.ietf.org/doc/html/rfc4291.html#section-2.5.5.2>"}),"_.\nWhen creating an IPADDRESS, IPv4 addresses will be mapped into that range."]}),"\n",(0,a.jsxs)(n.p,{children:["When formatting an IPADDRESS, any address within the mapped range will be formatted as an IPv4 address.\nOther addresses will be formatted as IPv6 using the canonical format defined in ",(0,a.jsx)(n.code,{children:"RFC 5952 <https://datatracker.ietf.org/doc/html/rfc5952.html>"}),"_."]}),"\n",(0,a.jsx)(n.p,{children:"IPV6 mapped IPV4 address:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04] -> 1.2.3.4\n"})}),"\n",(0,a.jsx)(n.p,{children:"Valid examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(from_hex('20010db8000000000000ff0000428329') as ipaddress); -- ipaddress '2001:db8::ff00:42:8329'\n  SELECT cast(from_hex('01020304') as ipaddress); -- ipaddress '1.2.3.4'\n  SELECT cast(from_hex('00000000000000000000ffff01020304') as ipaddress); -- ipaddress '1.2.3.4'\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(from_hex('f000001100') as ipaddress); -- Invalid IP address binary length: 5\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-ipprefix-1",children:"From IPPREFIX"}),"\n",(0,a.jsx)(n.p,{children:"Returns the canonical(lowest) IPADDRESS in the subnet range."}),"\n",(0,a.jsx)(n.p,{children:"Examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"\n  SELECT cast(ipprefix '1.2.3.4/24' as ipaddress) -- ipaddress '1.2.3.0'\n  SELECT cast(ipprefix '2001:db8::ff00:42:8329/64' as ipaddress) -- ipaddress '2001:db8::'\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cast-to-ipprefix",children:"Cast to IPPREFIX"}),"\n",(0,a.jsx)(n.h3,{id:"from-varchar-7",children:"From VARCHAR"}),"\n",(0,a.jsxs)(n.p,{children:["The IPPREFIX string must be in the form of ",(0,a.jsxs)(n.em,{children:[(0,a.jsx)(n.code,{children:"<ip_address>"}),"/",(0,a.jsx)(n.code,{children:"<ip_prefix>"})]})," as defined in ",(0,a.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/rfc4291.html#section-2.3",children:"RFC 4291#section-2.3"}),".\nThe IPADDRESS portion of the IPPREFIX follows the same rules as casting\n",(0,a.jsx)(n.code,{children:"IPADDRESS from VARCHAR <#ipaddress-from-varchar>"}),"_."]}),"\n",(0,a.jsxs)(n.p,{children:["The prefix portion must be ",(0,a.jsx)(n.code,{children:"<= 32"})," if the IP is an IPv4 address or ",(0,a.jsx)(n.code,{children:"<= 128"})," for an IPv6 address.\nAs with IPADDRESS, any IPv6 address in the form of an IPv4 mapped IPv6 address will be\ninterpreted as an IPv4 address. Only the canonical(smallest) IP address will be stored\nin the IPPREFIX."]}),"\n",(0,a.jsx)(n.p,{children:"Examples:"}),"\n",(0,a.jsx)(n.p,{children:"Valid examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast('2001:0db8:0000:0000:0000:ff00:0042:8329/32' as ipprefix); -- ipprefix '2001:0db8::/32'\n  SELECT cast('1.2.3.4/24' as ipprefix); -- ipprefix '1.2.3.0/24'\n  SELECT cast('::ffff:ffff:ffff/16' as ipprefix); -- ipprefix '255.255.0.0/16'\n"})}),"\n",(0,a.jsx)(n.p,{children:"Invalid examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"\n  SELECT cast('2001:db8::1::1/1' as ipprefix); -- Cannot cast value to IPPREFIX: 2001:db8::1::1/1\n  SELECT cast('2001:0db8:0000:0000:0000:ff00:0042:8329/129' as ipprefix); -- Cannot cast value to IPPREFIX: 2001:0db8:0000:0000:0000:ff00:0042:8329/129\n  SELECT cast('2001:0db8:0000:0000:0000:ff00:0042:8329/-1' as ipprefix); -- Cannot cast value to IPPREFIX: 2001:0db8:0000:0000:0000:ff00:0042:8329/-1\n  SELECT cast('255.2.3.4/33' as ipprefix); -- Cannot cast value to IPPREFIX: 255.2.3.4/33\n  SELECT cast('::ffff:ffff:ffff/33' as ipprefix); -- Cannot cast value to IPPREFIX: ::ffff:ffff:ffff/33\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-ipaddress-1",children:"From IPADDRESS"}),"\n",(0,a.jsx)(n.p,{children:"Returns an IPPREFIX where the prefix length is the length of the entire IP address.\nPrefix length for IPv4 is 32 and for IPv6 it is 128."}),"\n",(0,a.jsx)(n.p,{children:"Examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"  SELECT cast(ipaddress '1.2.3.4' as ipprefix) -- ipprefix '1.2.3.4/32'\n  SELECT cast(ipaddress '2001:db8::ff00:42:8329' as ipprefix) -- ipprefix '2001:db8::ff00:42:8329/128'\n"})}),"\n",(0,a.jsx)(n.h2,{id:"data-size-functions",children:"Data Size Functions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"    parse_presto_data_size(string) -> decimal(38)\n\n    Parses ``string`` of format ``value unit`` into a number, where ``value`` is the fractional number of unit values::\n\n      SELECT parse_presto_data_size('1B'); -- 1\n      SELECT parse_presto_data_size('1kB'); -- 1024\n      SELECT parse_presto_data_size('1MB'); -- 1048576\n      SELECT parse_presto_data_size('2.3MB'); -- 2411724\n"})}),"\n",(0,a.jsx)(n.h2,{id:"miscellaneous",children:"Miscellaneous"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"    typeof(x) -> varchar\n\n    Returns the name of the type of x::\n\n        SELECT typeof(123); -- integer\n        SELECT typeof(1.5); -- double\n        SELECT typeof(array[1,2,3]); -- array(integer)\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>t});var a=s(96540);const i={},l=a.createContext(i);function r(e){const n=a.useContext(l);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(l.Provider,{value:n},e.children)}}}]);