"use strict";(self.webpackChunkkumo_website=self.webpackChunkkumo_website||[]).push([[98262],{75062:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var t=s(74848),i=s(28453);const o={},a="Timestamp and Timezone Management",r={id:"pollux/develop/timestamp",title:"Timestamp and Timezone Management",description:"Following ANSI SQL semantics, TIMESTAMP is a data type that represents a",source:"@site/versioned_docs/version-1.1.1/pollux/develop/timestamp.mdx",sourceDirName:"pollux/develop",slug:"/pollux/develop/timestamp",permalink:"/docs/pollux/develop/timestamp",draft:!1,unlisted:!1,tags:[],version:"1.1.1",lastUpdatedBy:"Jeff lothar",lastUpdatedAt:1748143706e3,frontMatter:{},sidebar:"docs",previous:{title:"Writer Fuzzer",permalink:"/docs/pollux/develop/testing/writer-fuzzer"},next:{title:"Window functions",permalink:"/docs/pollux/develop/window"}},c={},l=[{value:"Pollux Classes and APIs",id:"pollux-classes-and-apis",level:2},{value:"Conversions Across Timezones",id:"conversions-across-timezones",level:2},{value:"Casts",id:"casts",level:2},{value:"Presto Cast Legacy Behavior",id:"presto-cast-legacy-behavior",level:2},{value:"Other Resources",id:"other-resources",level:2}];function m(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"timestamp-and-timezone-management",children:"Timestamp and Timezone Management"})}),"\n",(0,t.jsx)(n.h1,{id:"concepts",children:"Concepts"}),"\n",(0,t.jsxs)(n.p,{children:["Following ANSI SQL semantics, TIMESTAMP is a data type that represents a\nreading of a wall clock and a calendar, e.g, ",(0,t.jsx)(n.code,{children:"2024-04-09 18:25:00"}),". Note that\na TIMESTAMP does not represent an absolute point in time, as the exact same\nwall clock time may be read in different instants in time depending on where\none is situated on Earth. For example, ",(0,t.jsx)(n.code,{children:"2024-04-09 18:25:00"})," in California\nand in China were perceived at different absolute points in time, about 15\nhours apart."]}),"\n",(0,t.jsxs)(n.p,{children:["To represent absolute points in time, SQL defines a TIMESTAMP WITH TIMEZONE\ntype, which conceptually represents a pair of a wall time and calendar read\n(say, ",(0,t.jsx)(n.code,{children:"2024-04-09 18:25:00"}),"), and a timezone (",(0,t.jsx)(n.code,{children:"PDT"}),", or\n",(0,t.jsx)(n.code,{children:"America/Los_Angeles"}),"). With these two values, one can unambiguously\nrepresent an absolute instant in time."]}),"\n",(0,t.jsx)(n.p,{children:"Naturally, a TIMESTAMP WITH TIMEZONE can be cast into a TIMESTAMP by just\nignoring the timezone and keeping the timestamp wall time, and a TIMESTAMP can\nbe cast into a TIMESTAMP WITH TIMEZONE by associating a timezone to it. The\ntimezone can either be explicitly specified by the users, or implicitly taken\nfrom the user system or session information."}),"\n",(0,t.jsx)(n.h1,{id:"physical-representation",children:"Physical Representation"}),"\n",(0,t.jsxs)(n.p,{children:["Representing timestamps in memory as a string or a set of values for year,\nmonth, day, hour, and so on, is inefficient. Therefore, timestamps are usually\nstored in a columnar layout as a 64 bit integer representing the number of\nseconds elapsed since ",(0,t.jsx)(n.code,{children:"1970-01-01 00:00:00"}),". Negative values represent time\nprior to that."]}),"\n",(0,t.jsxs)(n.p,{children:["However, note that the physical representation of the timestamp is orthogonal\nto its logical meaning. For example, the timestamp represented by the ",(0,t.jsx)(n.code,{children:"0"}),"\ninteger was perceived at different absolute points in time depending on the\nobserver\u2019s timezone, and does not necessarily imply that it was observed in the\nUTC timezone. When a timestamp represents the number of seconds in UTC\nspecifically (at that exact absolute instant in time), it may be called a ",(0,t.jsx)(n.em,{children:"unix\nepoch"})," or ",(0,t.jsx)(n.em,{children:"unix time"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"pollux-classes-and-apis",children:"Pollux Classes and APIs"}),"\n",(0,t.jsx)(n.p,{children:"Pollux provides a few classes and APIs to allow developers to store, process,\nand convert timestamps across timezones:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Timestamp:"})," In Pollux, timestamps are represented by the ",(0,t.jsx)(n.a,{href:"https://github.com/facebookincubator/pollux/blob/main/pollux/type/Timestamp.h",children:"Timestamp"}),"\nclass. The Timestamp class stores two 64 bit integers, one containing the\nnumber of seconds from ",(0,t.jsx)(n.code,{children:"1970-01-01 00:00:00"}),", and one containing the\nnanoseconds offset in that particular second, in order to provide nanosecond\nprecision. A few more observations:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["While \u201cseconds\u201d can be negative to represent time before ",(0,t.jsx)(n.code,{children:"1970-01-01 00:00:00"}),", \u201cnanoseconds\u201d are always positive."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Although Pollux supports nanoseconds precision, engines like Presto and Spark\nmay only need milliseconds or microsecond precision."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"The Timestamp class only offers a physical representation of timestamps, but\ndoes not carry logical information about its timezone. In other words, it\ncannot, by itself, represent an absolute point in time."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Timezone IDs:"})," To physically represent timezones, Pollux provides the\n",(0,t.jsx)(n.code,{children:"TimezoneMap.h <https://github.com/facebookincubator/pollux/blob/main/pollux/type/tz/TimeZoneMap.h>"}),"_\nAPI. This API provides a 1:1 mapping from each available timezone to a\nmonotonically increasing integer (a timezone ID), such that this integer can be\nused to efficiently represent timezones, preventing the use of inefficient\ntimezone string names like ",(0,t.jsx)(n.code,{children:"America/Los_Angeles"}),". Considering there are about\n2k valid timezone definitions, 12 bits are enough to represent timezone IDs.\xa0"]}),"\n",(0,t.jsxs)(n.p,{children:["Timezone IDs in Pollux are based on the id map used by Presto and are\n",(0,t.jsx)(n.code,{children:"available here <https://github.com/prestodb/presto/blob/master/presto-common/src/main/resources/com/facebook/presto/common/type/zone-index.properties>"}),(0,t.jsxs)(n.em,{children:[".\nThey are automatically generated using ",(0,t.jsx)(n.code,{children:"this script <https://github.com/facebookincubator/pollux/blob/main/pollux/type/tz/gen_timezone_database.py>"})]}),".\nWhile timezone IDs are an implementation detail and ideally should not leak\noutside of Pollux execution, they are exposed if data containing\nTimestampWithTimezones are serialized, for example."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"TimestampWithTimezone:"})," To represent an absolute point in time, Pollux provides\n",(0,t.jsx)(n.code,{children:"TimestampWithTimezone <https://github.com/facebookincubator/pollux/blob/main/pollux/functions/prestosql/types/TimestampWithTimeZoneType.h>"}),"_.\nThis abstraction implements the TIMESTAMP WITH TIMEZONE SQL semantic discussed\nabove, and is based on Presto\u2019s implementation - therefore only supporting\nmillisecond-precision."]}),"\n",(0,t.jsx)(n.p,{children:"TimestampWithTimezone physically packs two integers in a single 64 word, using\n12 bits for timezone ID, and 52 bits for a millisecond-precision timestamp."}),"\n",(0,t.jsxs)(n.p,{children:["Note that to accelerate timestamp conversion functions, the timestamps stored\nin a TimestampWithTimezone are ",(0,t.jsx)(n.strong,{children:"always relative to UTC"})," - they are unix epochs.\nThis means that converting a TimestampWithTimezone across timezones is\nefficiently done by just overwriting the 12 bits, and that comparisons can be\ndone by just comparing the 52 bits relative to timestamp (ignoring the timezone\nID)."]}),"\n",(0,t.jsxs)(n.p,{children:["However, unpacking/converting a TimestampWithTimezone into an absolute time\ndefinition requires a\n",(0,t.jsx)(n.code,{children:"timezone conversion <https://github.com/facebookincubator/pollux/blob/main/pollux/functions/prestosql/DateTimeFunctions.h#L74-L84>"}),"_."]}),"\n",(0,t.jsx)(n.h2,{id:"conversions-across-timezones",children:"Conversions Across Timezones"}),"\n",(0,t.jsxs)(n.p,{children:["A common operation required when processing timestamps and timezone is finding\nthe wall clock and calendar read in a specific timezone given an absolute point\nin time described by a wall clock and calendar read in a different timezone.\nFor example, at the exact point in time when UTC hits ",(0,t.jsx)(n.code,{children:"1970-01-01 00:00:00"}),",\nwhat was the wall clock read in China?"]}),"\n",(0,t.jsxs)(n.p,{children:["Timezone conversions are tricky since they are non-linear and depend on\ndaylight savings time schedules and other local regulations, and these change\nover time. To enable such conversions, ",(0,t.jsx)(n.code,{children:"IANA <https://www.iana.org/time-zones>"}),"_\nperiodically publishes a global source of authority database for timezone\nconversions, which is periodically pushed to systems using packages like tzdata\nfor Linux.\xa0"]}),"\n",(0,t.jsxs)(n.p,{children:["In Pollux, Timezone conversions are done using std::chrono. Starting in C++20,\nstd::chrono ",(0,t.jsx)(n.code,{children:"supports conversion of timestamp across timezones <https://en.cppreference.com/w/cpp/chrono/time_zone>"}),(0,t.jsxs)(n.em,{children:[".\nTo support older versions of the C++ standard, in Pollux we vendor an\nimplementation of this API at ",(0,t.jsx)(n.code,{children:"pollux/external/tzdb/ <https://github.com/facebookincubator/pollux/tree/main/pollux/external/tzdb>"})]}),".\nThis class handles timezone conversions by leveraging APIs provided by the\noperating system, based on the tzdata database installed locally. If systems\nhappen to have inconsistent or older versions of the tzdata database, Pollux\u2019s\nconversions may produce inconsistent results.\xa0"]}),"\n",(0,t.jsx)(n.p,{children:"On Linux, you can check the tzdata installed in your system by:"}),"\n",(0,t.jsx)(n.p,{children:".. code-block:: bash"}),"\n",(0,t.jsx)(n.p,{children:"$ rpm -qa | grep tzdata\ntzdata-2024a-1.fc38.noarch"}),"\n",(0,t.jsxs)(n.p,{children:["Timezone conversions are done using special methods in the Timestamp class:\n",(0,t.jsx)(n.code,{children:"Timestamp::toGMT()"})," and ",(0,t.jsx)(n.code,{children:"Timestamp::toTimezone()"}),". They can take either a\ntimezone ID or a tz::TimeZone pointer. Providing a tz::TimeZone is\ngenerally more efficient, but std::chrono does not handle time zone offsets\nsuch as ",(0,t.jsx)(n.code,{children:"+09:00"}),".  Timezone offsets are only supported in the API version\nthat takes a timezone ID."]}),"\n",(0,t.jsx)(n.h2,{id:"casts",children:"Casts"}),"\n",(0,t.jsxs)(n.p,{children:["This section describes examples of timestamp casts following ANSI SQL\nsemantics, using ",(0,t.jsx)(n.code,{children:"Presto as a reference implementation <https://prestodb.io/docs/current/functions/datetime.html>"}),"_,\nusing ",(0,t.jsx)(n.code,{children:"set session legacy_timestamp = false;"})," (see the section below for\ndetails)."]}),"\n",(0,t.jsx)(n.p,{children:"Timestamp literals are created based on whether time zone information is found\non the string on not:"}),"\n",(0,t.jsx)(n.p,{children:"::"}),"\n",(0,t.jsx)(n.p,{children:"SELECT typeof(TIMESTAMP '1970-01-01 00:00:00'); -- timestamp\nSELECT typeof(TIMESTAMP '1970-01-01 00:00:00 UTC'); -- timestamp with time zone"}),"\n",(0,t.jsx)(n.p,{children:"Converting a TimestampWithTimezone into a Timestamp works by dropping the\ntimezone information and returning only the timestamp portion:"}),"\n",(0,t.jsx)(n.p,{children:"::"}),"\n",(0,t.jsx)(n.p,{children:"SELECT cast(TIMESTAMP '1970-01-01 00:00:00 UTC' as timestamp); -- 1970-01-01 00:00:00.000\nSELECT cast(TIMESTAMP '1970-01-01 00:00:00 America/New_York' as timestamp); -- 1970-01-01 00:00:00.000"}),"\n",(0,t.jsx)(n.p,{children:"To convert a Timestamp into a TimestampWithTimezone, one needs to specify a\ntimezone. In Presto, the session timezone is used by default:"}),"\n",(0,t.jsx)(n.p,{children:"::"}),"\n",(0,t.jsx)(n.p,{children:"SELECT current_timezone(); -- America/Los_Angeles\nSELECT cast(TIMESTAMP '1970-01-01 00:00:00' as timestamp with time zone); -- 1970-01-01 00:00:00.000 America/Los_Angeles"}),"\n",(0,t.jsx)(n.p,{children:"Conversion across TimestampWithTimezone can be done using the AT TIME ZONE\nconstruct."}),"\n",(0,t.jsxs)(n.p,{children:["The semantic of this operation is: at the absolute point in time described by\nthe source TimestampWithTimezone (",(0,t.jsx)(n.code,{children:"1970-01-01 00:00:00 UTC"}),"), what would be\nthe clock/calendar read at the target timezone (Los Angeles)?"]}),"\n",(0,t.jsx)(n.p,{children:"::"}),"\n",(0,t.jsx)(n.p,{children:"SELECT TIMESTAMP '1970-01-01 00:00:00 UTC' AT TIME ZONE 'America/Los_Angeles'; -- 1969-12-31 16:00:00.000 America/Los_Angeles\nSELECT TIMESTAMP '1970-01-01 00:00:00 UTC' AT TIME ZONE 'UTC'; -- 1970-01-01 00:00:00.000 UTC"}),"\n",(0,t.jsx)(n.p,{children:"Strings can be converted into Timestamp and TimestampWithTimezone:"}),"\n",(0,t.jsx)(n.p,{children:"::"}),"\n",(0,t.jsx)(n.p,{children:"SELECT cast('1970-01-01 00:00:00' as timestamp); -- 1970-01-01 00:00:00.000\nSELECT cast('1970-01-01 00:00:00 America/Los_Angeles' as timestamp with time zone); -- 1970-01-01 00:00:00.000 America/Los_Angeles"}),"\n",(0,t.jsxs)(n.p,{children:["One can also convert a TimestampWithTimezone into a unix epoch/time. The\nsemantic of this operation is: at the absolute point in time described by the\ntimestamp with timezone taken as a parameter, what was the unix epoch? Remember\nthat unix epoch is the number of seconds since ",(0,t.jsx)(n.code,{children:"1970-01-01 00:00:00"})," in UTC:"]}),"\n",(0,t.jsx)(n.p,{children:"::"}),"\n",(0,t.jsx)(n.p,{children:"SELECT to_unixtime(TIMESTAMP '1970-01-01 00:00:00 UTC'); -- 0.0\nSELECT to_unixtime(TIMESTAMP '1970-01-01 00:00:00 America/Los_Angeles'); -- 28800.0"}),"\n",(0,t.jsxs)(n.p,{children:["The opposite conversion can be achieved using ",(0,t.jsx)(n.code,{children:"from_unixtime()"}),". The function\nmay take an optional second parameter to specify the timezone, having the same\nsemantic as AT TIME ZONE described above:"]}),"\n",(0,t.jsx)(n.p,{children:"::"}),"\n",(0,t.jsx)(n.p,{children:"SELECT from_unixtime(0); -- 1970-01-01 00:00:00.000\nSELECT from_unixtime(0, 'UTC'); -- 1970-01-01 00:00:00.000 UTC\xa0\nSELECT from_unixtime(0, 'America/Los_Angeles'); -- 1969-12-31 16:00:00.000 America/Los_Angeles"}),"\n",(0,t.jsx)(n.h2,{id:"presto-cast-legacy-behavior",children:"Presto Cast Legacy Behavior"}),"\n",(0,t.jsxs)(n.p,{children:["For historical reasons, Presto used to interpret a TIMESTAMP as an absolute\npoint in time at the user\u2019s time zone, instead of a timezone-less wall clock\nreading as the ANSII SQL defines it. More information\n",(0,t.jsx)(n.a,{href:"https://github.com/prestodb/presto/issues/7122",children:"can be found here"})]}),"\n",(0,t.jsxs)(n.p,{children:["Although this has been fixed in newer versions, a ",(0,t.jsx)(n.code,{children:"legacy_timestamp"})," session\nflag was added to preserve backwards compatibility. When this flag is set,\ntimestamps have a different semantic:"]}),"\n",(0,t.jsx)(n.p,{children:"::"}),"\n",(0,t.jsx)(n.p,{children:"SET SESSION legacy_timestamp = true;\nSELECT cast(TIMESTAMP '1970-01-01 00:00:00 UTC' as timestamp); -- 1969-12-31 16:00:00.000\nSELECT cast('1970-01-01 00:00:00 UTC' as timestamp); -- 1969-12-31 16:00:00.000"}),"\n",(0,t.jsxs)(n.p,{children:["To support the two timestamp semantics, the\n",(0,t.jsx)(n.code,{children:"core::QueryConfig::kAdjustTimestampToTimezone"})," query flag was added to Pollux.\nWhen this flag is set, Pollux will convert the timestamp into the user\u2019s session\ntime zone to follow the expected semantic, although non-ANSI SQL compliant."]}),"\n",(0,t.jsx)(n.h2,{id:"other-resources",children:"Other Resources"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/prestodb/presto/issues/7122",children:"https://github.com/prestodb/presto/issues/7122"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/a0x8o/presto/blob/master/presto-docs/src/main/sphinx/language/timestamp.rst",children:"https://github.com/a0x8o/presto/blob/master/presto-docs/src/main/sphinx/language/timestamp.rst"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/facebookincubator/pollux/issues/8037",children:"https://github.com/facebookincubator/pollux/issues/8037"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>r});var t=s(96540);const i={},o=t.createContext(i);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);