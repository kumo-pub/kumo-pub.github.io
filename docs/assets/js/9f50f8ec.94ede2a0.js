"use strict";(self.webpackChunkkumo_website=self.webpackChunkkumo_website||[]).push([[58995],{13925:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>c,toc:()=>d});var i=s(74848),t=s(28453);const a={},r="Decimal Operators",c={id:"pollux/functions/presto/decimal",title:"Decimal Operators",description:"DECIMAL type is designed to represent floating point numbers precisely.",source:"@site/versioned_docs/version-1.1.1/pollux/functions/presto/decimal.mdx",sourceDirName:"pollux/functions/presto",slug:"/pollux/functions/presto/decimal",permalink:"/docs/pollux/functions/presto/decimal",draft:!1,unlisted:!1,tags:[],version:"1.1.1",lastUpdatedBy:"Jeff lothar",lastUpdatedAt:1748143706e3,frontMatter:{},sidebar:"docs",previous:{title:"string",permalink:"/docs/pollux/functions/presto/string"},next:{title:"Date and Time Functions and Operators",permalink:"/docs/pollux/functions/presto/datetime"}},o={},d=[{value:"Addition and Subtraction",id:"addition-and-subtraction",level:2},{value:"Multiplication",id:"multiplication",level:2},{value:"Division",id:"division",level:2},{value:"Modulus",id:"modulus",level:2},{value:"Decimal Functions",id:"decimal-functions",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"decimal-operators",children:"Decimal Operators"})}),"\n",(0,i.jsx)(n.p,{children:"DECIMAL type is designed to represent floating point numbers precisely.\nMathematical operations on decimal values are exact, except for division. On\nthe other hand, DOUBLE and REAL types are designed to represent floating point\nnumbers approximately. Mathematical operations on double and real values are\napproximate."}),"\n",(0,i.jsxs)(n.p,{children:["For example, the number 5,000,000,000,000,000 can be represented using DOUBLE.\nHowever, the number 5,000,000,000,000,000.15 cannot be represented using\nDOUBLE, but it can be represented using DECIMAL. See\n",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Double-precision_floating-point_format",children:"https://en.wikipedia.org/wiki/Double-precision_floating-point_format"})," for more\ndetails."]}),"\n",(0,i.jsx)(n.p,{children:"DECIMAL type has 2 parameters: precision and scale. Precision is the total\nnumber of digits used to represent the number. Scale is the number of digits\nafter the decimal point. Naturally, scale must not exceed precision. In\naddition, precision cannot exceed 38."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"`\n\tdecimal(p, s)\n\n\tp >= 1 && p <= 38\n\ts >= 0 && s <= p\n"})}),"\n",(0,i.jsx)(n.p,{children:"The number 5,000,000,000,000,000.15 can be represented using DECIMAL(18, 2).\nThis number needs at least 18 digits (precision) of which at least 2 digits\nmust appear after the decimal point (scale). This number can be represented\nusing any DECIMAL type where scale >= 2 and precision is >= scale + 16."}),"\n",(0,i.jsx)(n.p,{children:"Note: This definition of precision and scale may appear counterintuitive. It is\nnot uncommon to think about the number of digits after the decimal point as\nprecision and the number of digits before the decimal point as scale."}),"\n",(0,i.jsx)(n.h2,{id:"addition-and-subtraction",children:"Addition and Subtraction"}),"\n",(0,i.jsx)(n.p,{children:"To represent the results of adding two decimal numbers we need to use max\n(s1, s2) digits after the decimal point and max(p1 - s1, p2 - s2) + 1 digits\nbefore the decimal point."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n\tp = max(p1 - s1, p2 - s2) + 1 + max(s1, s2)\n\ts = max(s1, s2)\n"})}),"\n",(0,i.jsx)(n.p,{children:"It is easiest to understand this formula by thinking about column addition where\nwe place two numbers one under the other and line up decimal points."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n        1.001\n     9999.5\n   -----------\n    10000.501\n"})}),"\n",(0,i.jsx)(n.p,{children:"We can see that the result needs max(s1, s2) digits after the decimal point and\nmax(p1 - s1, p2 - s2) + 1 digits before the decimal point."}),"\n",(0,i.jsxs)(n.p,{children:["The precision of the result may exceed 38. There are two options. One option is\nto say that addition and subtraction is supported as long as ",(0,i.jsx)(n.code,{children:"p <= 38"})," and reject\noperations that produce ",(0,i.jsx)(n.code,{children:"p > 38"}),". Another option is to cap p at 38 and allow the\noperation to succeed as long as the actual result can be represented using 38\ndigits. In this case, users experience runtime errors when the actual result\ncannot be represented using 38 digits. Presto implements the second option. Pollux\nimplementation matches Presto."]}),"\n",(0,i.jsx)(n.h2,{id:"multiplication",children:"Multiplication"}),"\n",(0,i.jsx)(n.p,{children:"To represent the results of multiplying two decimal numbers we need s1 + s2\ndigits after the decimal point and p1 + p2 digits overall."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\tp = p1 + p2\n\ts = s1 + s2\n"})}),"\n",(0,i.jsx)(n.p,{children:"To multiply two numbers we can multiply them as integers ignoring the decimal\npoints, then add up the number of digits after the decimal point in the\noriginal numbers and place the decimal point that many digits away in the\nresult."}),"\n",(0,i.jsx)(n.p,{children:"To multiply 0.01 with 0.001, we can multiply 1 with 1, then place the decimal\npoint 5 digits to the left: 0.00001. Hence, the scale of the result is the sum\nof scales of the inputs."}),"\n",(0,i.jsxs)(n.p,{children:["When multiplying two integers with p1 and p2 digits respectively we get a result\nthat is strictly less than ",(0,i.jsx)(n.code,{children:"10^p1 * 10^p2 = 10^(p1 + p2)"}),". Hence, we need at most\np1 + p2 digits to represent the result."]}),"\n",(0,i.jsxs)(n.p,{children:["Both scale and precision of the result may exceed 38. There are two options\nagain. One option is to say that multiplication is supported as long as ",(0,i.jsx)(n.code,{children:"p <=38"}),"\n(by definition, s does not exceed p and therefore does not exceed 38 if ",(0,i.jsx)(n.code,{children:"p <=38"}),").\nAnother option is to cap p and s at 38 and allow operation to succeed as\nlong as the actual result can be represented as a decimal(38, s). In this case,\nusers experience runtime errors when the actual result cannot be represented as a\ndecimal(38, s). Presto implements a third option. Reject the operation if s\nexceeds 38 and cap p at 38 when ",(0,i.jsx)(n.code,{children:"s <= 38"}),". In this case some operations are rejected\noutright while others are allowed to proceed, but may produce runtime errors. Pollux\nimplementation matches Presto."]}),"\n",(0,i.jsx)(n.h2,{id:"division",children:"Division"}),"\n",(0,i.jsx)(n.p,{children:"Perfect division is not possible. For example, 1 / 3 cannot be represented as a\ndecimal value."}),"\n",(0,i.jsx)(n.p,{children:"When dividing a number with p1 digits over a number of s2 scale, the biggest result requires s2 extra digits before the\ndecimal point. To get the largest number we must divide by 0.0000001, which effectively is a multiplication by 10^s2.\nHence, precision of the result needs to be at least p1 + s2."}),"\n",(0,i.jsx)(n.p,{children:"Presto also chooses to extend the scale of the result to a maximum of scales of\nthe inputs."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\ts = max(s1, s2)\n"})}),"\n",(0,i.jsx)(n.p,{children:"To support increased scale, the result precision needs to be extended by the\ndifference in s1 and s."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\n\tp = p1 + s2 + max(0, s2 - s1)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Like in Addition, the precision of the result may exceed 38. The choices are the\nsame. Presto chooses to cap p at 38 and allow runtime errors."}),"\n",(0,i.jsxs)(n.p,{children:["Let\u2019s say ",(0,i.jsx)(n.code,{children:"a"})," is of type decimal(p1, s1) with unscaled value ",(0,i.jsx)(n.code,{children:"A"})," and ",(0,i.jsx)(n.code,{children:"b"})," is of\ntype decimal(p2, s2) with unscaled value B."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    a = A / 10^s1\n    b = B / 10^s2\n"})}),"\n",(0,i.jsx)(n.p,{children:"The result type precision and scale are:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\ts = max(s1, s2)\n\tp = p1 + s2 + max(0, s2 - s1)\n"})}),"\n",(0,i.jsx)(n.p,{children:"The result 'r' has 's' digits after the decimal point and unscaled value R. We\nderive the value of R as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\n   r = a / b = (A / 10^s1) / (B / 10^s2) = A * 10^(s2 - s1) / B\n   r = R / 10^s\n   R = r * 10^s = A * 10^(s + s2 - s1) / B\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To compute R, first rescale A using the rescale factor :code:",(0,i.jsx)(n.code,{children:"(s + s2 - s1)"}),",\nthen divide by B and round to the nearest whole. This method works as long as\nrescale factor does not exceed 38. If :code:",(0,i.jsx)(n.code,{children:"s + s2 - s1"})," exceeds 38, an error\nis raised."]}),"\n",(0,i.jsx)(n.p,{children:"The formula for the scale of the result is a choice. Presto chose max(s1, s2).\nOther systems made different choices."}),"\n",(0,i.jsx)(n.p,{children:"It is not clear why Presto chose max(s1, s2). Perhaps, the thinking was to\nassume that user's desired accuracy is the max of input scales. However, one\ncould also say that desired accuracy is the scale of the dividend. In SQL,\nliteral values get their types assigned by the actual number of digits after\nthe decimal point. Hence, in the following SQL 1.2 has scale 1 and 0.01 has\nscale 2. One may argue that user's intention is to work with accuracy of 2\ndigits after the decimal point, hence, max(s1, s2)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    SELECT 1.2 / 0.01\n"})}),"\n",(0,i.jsx)(n.h2,{id:"modulus",children:"Modulus"}),"\n",(0,i.jsxs)(n.p,{children:["For the modulus operation :code:",(0,i.jsx)(n.code,{children:"a % b"}),", when a and b are integers, the result\n",(0,i.jsx)(n.code,{children:"r"})," is less than ",(0,i.jsx)(n.code,{children:"b"})," and less than or equal to ",(0,i.jsx)(n.code,{children:"a"}),". Hence the number of digits\nneeded to represent ",(0,i.jsx)(n.code,{children:"r"})," is no more than the minimum of the number of digits\nneeded to represent ",(0,i.jsx)(n.code,{children:"a"})," or ",(0,i.jsx)(n.code,{children:"b"}),". We can extend this to decimal inputs ",(0,i.jsx)(n.code,{children:"a"})," and\n",(0,i.jsx)(n.code,{children:"b"})," by computing the modulus of their unscaled values. However, we should\nfirst make sure that ",(0,i.jsx)(n.code,{children:"a"})," and ",(0,i.jsx)(n.code,{children:"b"})," have the same scale. This can be achieved by\nscaling up the input with lesser scale by the difference in the inputs' scales,\nso both ",(0,i.jsx)(n.code,{children:"a"})," and ",(0,i.jsx)(n.code,{children:"b"})," have scale s. Once ",(0,i.jsx)(n.code,{children:"a"})," and ",(0,i.jsx)(n.code,{children:"b"})," have the same scale, we\ncompute the modulus of their unscaled values, A and B. ",(0,i.jsx)(n.code,{children:"r"})," has s digits after\nthe decimal point, and since ",(0,i.jsx)(n.code,{children:"r"})," does not need any more digits than the\nminimum number of digits needed to represent ",(0,i.jsx)(n.code,{children:"a"})," or ",(0,i.jsx)(n.code,{children:"b"}),", the result precision\nneeds to be increased by the smaller of the differences in the precision and\nscale of either inputs. Hence the result type precision and scale are:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    s = max(s1, s2)\n    p = min(p2 - s2, p1 - s1) + max(s1, s2)\n"})}),"\n",(0,i.jsx)(n.p,{children:"To compute R, we first rescale A and B to 's':"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    A = a * 10^s1\n    B = b * 10^s2\n\n    A' = a * 10^s\n    B' = b * 10^s\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then we compute modulus of the rescaled values:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    R = A' % B' = r * 10^s\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For example, say ",(0,i.jsx)(n.code,{children:"a"})," = 12.3 and ",(0,i.jsx)(n.code,{children:"b"})," = 1.21, ",(0,i.jsx)(n.code,{children:"r"})," = :code:",(0,i.jsx)(n.code,{children:"a % b"})," is calculated\nas follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    s = max(1, 2) = 2\n    p = min(2, 1) + s = 3\n\n    A = 12.3 * 10^1 = 123\n    B = 1.21 * 10^2 = 121\n\n    A' = 12.3 * 10^2 = 1230\n    B' = 1.21 * 10^2 = 121\n\n    R = 1230 % 121 = 20 = 0.20 * 100\n"})}),"\n",(0,i.jsx)(n.h2,{id:"decimal-functions",children:"Decimal Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"    abs(x: decimal(p, s)) -> r: decimal(p, s)\n\n    Returns absolute value of x (r = `|x|`).\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"    divide(x: decimal(p1, s1), y: decimal(p2, s2)) -> r: decimal(p, s)\n\n    Returns the result of dividing x by y (r = x / y).\n\n    x and y are decimal values with possibly different precisions and scales. The\n    precision and scale of the result are calculated as follows:\n    ::\n\n        p = min(38, p1 + s2 + max(0, s2 - s1))\n        s = max(s1, s2)\n\n    Throws if y is zero, or result cannot be represented using precision calculated\n    above, or rescale factor `max(s1, s2) - s1 + s2` exceeds 38.\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"    floor(x: decimal(p, s)) -> r: decimal(pr, 0)\n\n    Returns 'x' rounded down to the nearest integer. The scale of the result is 0.\n    The precision is calculated as:\n    ::\n\n        pr = min(38, p - s + min(s, 1))\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"    minus(x: decimal(p1, s1), y: decimal(p2, s2)) -> r: decimal(p, s)\n\n    Returns the result of subtracting y from x (r = x - y).\n\n    x and y are decimal values with possibly different precisions and scales. The\n    precision and scale of the result are calculated as follows:\n    ::\n\n        p = min(38, max(p1 - s1, p2 - s2) + 1 + max(s1, s2))\n        s = max(s1, s2)\n\n    Throws if result cannot be represented using precision calculated above.\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"    modulus(x: decimal(p1, s1), y: decimal(p2, s2)) -> r: decimal(p, s)\n\n    Returns the remainder from division of x by y (r = x % y).\n\n    x and y are decimal values with possibly different precisions and scales. The\n    precision and scale of the result are calculated as follows:\n    ::\n\n        p = min(p2 - s2, p1 - s1) + max(s1, s2)\n        s = max(s1, s2)\n\n    Throws if y is zero.\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"    multiply(x: decimal(p1, s1), y: decimal(p2, s2)) -> r: decimal(p, s)\n\n    Returns the result of multiplying x by y (r = x * y).\n\n    x and y are decimal values with possibly different precisions and scales. The\n    precision and scale of the result are calculated as follows:\n    ::\n\n        p = min(38, p1 + p2)\n        s = s1 + s2\n\n    The operation is not supported if s1 + s2 exceeds 38.\n\n    Throws if result cannot be represented using precision calculated above.\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"    negate(x: decimal(p, s)) -> r: decimal(p, s)\n\n    Returns negated value of x (r = -x).\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"    plus(x: decimal(p1, s1), y: decimal(p2, s2)) -> r: decimal(p, s)\n\n    Returns the result of adding x to y (r = x + y).\n\n    x and y are decimal values with possibly different precisions and scales. The\n    precision and scale of the result are calculated as follows:\n    ::\n\n        p = min(38, max(p1 - s1, p2 - s2) + 1 + max(s1, s2))\n        s = max(s1, s2)\n\n    Throws if result cannot be represented using precision calculated above.\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"    round(x: decimal(p, s)) -> r: decimal(rp, 0)\n\n    Returns 'x' rounded to the nearest integer. The scale of the result is 0.\n    The precision is calculated as:\n    ::\n\n        pr = min(38, p - s + min(s, 1))\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"    round(x: decimal(p, s), d: integer) -> r: decimal(rp, s)\n\n    Returns 'x' rounded to 'd' decimal places. The scale of the result is\n    the same as the scale of the input. The precision is calculated as:\n    ::\n\n        p = min(38, p + 1)\n\n    'd' can be positive, zero or negative. Returns 'x' unmodified if 'd' exceeds\n    the scale of the input.\n\n    ::\n\n        SELECT round(123.45, 0); -- 123.00\n        SELECT round(123.45, 1); -- 123.50\n        SELECT round(123.45, 2); -- 123.45\n        SELECT round(123.45, 3); -- 123.45\n        SELECT round(123.45, -1); -- 120.00\n        SELECT round(123.45, -2); -- 100.00\n        SELECT round(123.45, -10); -- 0.00\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"    truncate(x: decimal(p, s)) -> r: decimal(rp, 0)\n\n    Returns 'x' rounded to integer by dropping digits after decimal point.\n    The scale of the result is 0. The precision is calculated as:\n    ::\n\n        pr = max(p - s, 1)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"    truncate(x: decimal(p, s), d: integer) -> r: decimal(rp, s)\n\n    Returns ``x`` truncated to ``d`` decimal places.\n    The precision and scale of the result are the same as the precision and scale of the input.\n    ``d`` can be positive, zero or negative.\n    When ``d`` is negative truncates ``-d`` digits left of the decimal point.\n    Returns ``x`` unmodified if ``d`` exceeds the scale of the input.\n    ::\n\n        SELECT truncate(999.45, 0); -- 999.00\n        SELECT truncate(999.45, 1); -- 999.40\n        SELECT truncate(999.45, 2); -- 999.45\n        SELECT truncate(999.45, 3); -- 999.45\n        SELECT truncate(999.45, -1); -- 990.00\n        SELECT truncate(999.45, -2); -- 900.00\n        SELECT truncate(999.45, -10); -- 0.00\n"})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var i=s(96540);const t={},a=i.createContext(t);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);