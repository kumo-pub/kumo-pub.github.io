"use strict";(self.webpackChunkkumo_website=self.webpackChunkkumo_website||[]).push([[57529],{70554:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var t=s(74848),a=s(28453);const o={},r="Comparison Functions",l={id:"pollux/functions/presto/comparison",title:"Comparison Functions",description:"",source:"@site/versioned_docs/version-1.1.1/pollux/functions/presto/comparison.mdx",sourceDirName:"pollux/functions/presto",slug:"/pollux/functions/presto/comparison",permalink:"/docs/pollux/functions/presto/comparison",draft:!1,unlisted:!1,tags:[],version:"1.1.1",lastUpdatedBy:"Jeff lothar",lastUpdatedAt:1748143706e3,frontMatter:{},sidebar:"docs",previous:{title:"Bitwise Functions",permalink:"/docs/pollux/functions/presto/bitwise"},next:{title:"Conversion Functions",permalink:"/docs/pollux/functions/presto/conversion"}},i={},c=[];function u(e){const n={code:"code",h1:"h1",header:"header",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"comparison-functions",children:"Comparison Functions"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    between(x, min, max) -> boolean\n\n    Returns true if x is within the specified [min, max] range\n    inclusive. Supports TINYINT, SMALLINT, INTEGER, BIGINT, DOUBLE,\n    REAL, VARCHAR, DATE types. The types of all arguments must be\n    the same.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    distinct_from(x, y) -> boolean\n\n    In SQL a ``NULL`` value signifies an unknown value, so any comparison\n    involving a ``NULL`` will produce NULL. The ``distinct_from`` treats\n    NULL as a known value and guarantees either a ``true`` or ``false``\n    outcome even in the presence of ``NULL`` input.\n    So ``distinct_from(NULL, NULL)`` returns ``false``, since a ``NULL``\n    value is not considered distinct from ``NULL``.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    eq(x, y) -> boolean\n\n    Returns true if x is equal to y. Supports all scalar types. The\n    types of x and y must be the same.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    greatest(value1, value2, ..., valueN) -> [same as input]\n\n    Returns the largest of the provided values. Supports DOUBLE, BIGINT,\n    VARCHAR, TIMESTAMP, DATE input types. The types of all arguments must\n    be the same.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    gt(x, y) -> boolean\n\n    Returns true if x is greater than y. Supports all scalar types. The\n    types of x and y must be the same.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    gte(x, y) -> boolean\n\n    Returns true if x is greater than or equal to y. Supports all scalar\n    types. The types of x and y must be the same.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    is_null(x) -> boolean\n\n    Returns true if x is a null. Supports all types.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    least(value1, value2, ..., valueN) -> [same as input]\n\n    Returns the smallest of the provided values. Supports DOUBLE, BIGINT,\n    VARCHAR, TIMESTAMP, DATE input types. The types of all arguments must\n    be the same.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    lt(x, y) -> boolean\n\n    Returns true if x is less than y. Supports all scalar types. The types\n    of x and y must be the same.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    lte(x, y) -> boolean\n\n    Returns true if x is less than or equal to y. Supports all scalar types.\n    The types of x and y must be the same.\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    neq(x, y) -> boolean\n\n    Returns true if x is not equal to y. Supports all scalar types. The types\n    of x and y must be the same.\n"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var t=s(96540);const a={},o=t.createContext(a);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);