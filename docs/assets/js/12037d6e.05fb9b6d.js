"use strict";(self.webpackChunkkumo_website=self.webpackChunkkumo_website||[]).push([[36483],{82801:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var t=r(74848),a=r(28453);const s={},i="Regular Expression Functions",o={id:"pollux/functions/presto/regexp",title:"Regular Expression Functions",description:"Regular expression functions use RE2 as the regex engine. RE2 is fast, but",source:"@site/versioned_docs/version-1.1.1/pollux/functions/presto/regexp.mdx",sourceDirName:"pollux/functions/presto",slug:"/pollux/functions/presto/regexp",permalink:"/docs/pollux/functions/presto/regexp",draft:!1,unlisted:!1,tags:[],version:"1.1.1",lastUpdatedBy:"Jeff lothar",lastUpdatedAt:1748143706e3,frontMatter:{}},c={},p=[];function l(e){const n={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"regular-expression-functions",children:"Regular Expression Functions"})}),"\n",(0,t.jsxs)(n.p,{children:["Regular expression functions use RE2 as the regex engine. RE2 is fast, but\nsupports only a subset of PCRE syntax and in particular does not support\nbacktracking and associated features (e.g. back references).\nSee ",(0,t.jsx)(n.a,{href:"https://github.com/google/re2/wiki/Syntax",children:"https://github.com/google/re2/wiki/Syntax"})," for more information."]}),"\n",(0,t.jsx)(n.p,{children:"Compiling regular expressions is CPU intensive. Hence, each function is\nlimited to 20 different expressions per instance and thread of execution."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    like(string, pattern) -> boolean\n              like(string, pattern, escape) -> boolean\n\n    Evaluates if the ``string`` matches the ``pattern``. Patterns can contain\n    regular characters as well as wildcards. Wildcard characters can be escaped\n    using the single character specified for the ``escape`` parameter. Only ASCII\n    characters are supported for the ``escape`` parameter. Matching is case sensitive.\n\n    Note: The wildcard '%' represents 0, 1 or multiple characters and the\n    wildcard '_' represents exactly one character.\n\n    Note: Each function instance allow for a maximum of 20 regular expressions to\n    be compiled per thread of execution. Not all patterns require\n    compilation of regular expressions. Patterns 'hello', 'hello%', '_hello__%',\n    '%hello', '%__hello_', '%hello%' where 'hello', 'pollux' contains only regular\n    characters and '_' wildcards are evaluated without using regular expressions,\n    and constant pattern '%hello%pollux%' where 'hello', 'pollux' contains only regular\n    characters(not contains '_' '#' wildcards) is evaluated with substrings-searching.\n    Only those patterns that require the compilation of regular expressions are\n    counted towards the limit.\n\n        SELECT like('abc', '%b%'); -- true\n        SELECT like('a_c', '%#_%', '#'); -- true\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regexp_extract(string, pattern) -> varchar\n\n    Returns the first substring matched by the regular expression ``pattern``\n    in ``string``::\n\n        SELECT regexp_extract('1a 2b 14m', '\\d+'); -- 1\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regexp_extract(string, pattern, group) -> varchar\n    :noindex:\n\n    Finds the first occurrence of the regular expression ``pattern`` in\n    ``string`` and returns the capturing group number ``group``::\n\n        SELECT regexp_extract('1a 2b 14m', '(\\d+)([a-z]+)', 2); -- 'a'\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regexp_extract_all(string, pattern) -> array(varchar):\n\n    Returns the substring(s) matched by the regular expression ``pattern``\n    in ``string``::\n\n        SELECT regexp_extract_all('1a 2b 14m', '\\d+'); -- [1, 2, 14]\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regexp_extract_all(string, pattern, group) -> array(varchar):\n    :noindex:\n\n    Finds all occurrences of the regular expression ``pattern`` in\n    ``string`` and returns the capturing group number ``group``::\n\n        SELECT regexp_extract_all('1a 2b 14m', '(\\d+)([a-z]+)', 2); -- ['a', 'b', 'm']\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regexp_like(string, pattern) -> boolean\n\n    Evaluates the regular expression ``pattern`` and determines if it is\n    contained within ``string``.\n\n    This function is similar to the ``LIKE`` operator, except that the\n    pattern only needs to be contained within ``string``, rather than\n    needing to match all of ``string``. In other words, this performs a\n    *contains* operation rather than a *match* operation. You can match\n    the entire string by anchoring the pattern using ``^`` and ``$``::\n\n        SELECT regexp_like('1a 2b 14m', '\\d+b'); -- true\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regexp_replace(string, pattern) -> varchar\n\n    Removes every instance of the substring matched by the regular expression\n    ``pattern`` from ``string``::\n\n        SELECT regexp_replace('1a 2b 14m', '\\d+[ab] '); -- '14m'\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regexp_replace(string, pattern, replacement) -> varchar\n    :noindex:\n\n    Replaces every instance of the substring matched by the regular expression\n    ``pattern`` in ``string`` with ``replacement``. Capturing groups can be referenced in\n    ``replacement`` using ``$g`` for a numbered group or ``${name}`` for a named group. A\n    dollar sign (``$``) may be included in the replacement by escaping it with a\n    backslash (``\\$``). If a backslash(``\\``) is followed by any character other\n    than a digit or another backslash(``\\``) in the replacement, the preceding\n    backslash(``\\``) will be ignored::\n\n        SELECT regexp_replace('1a 2b 14m', '(\\d+)([ab]) ', '3c$2 '); -- '3ca 3cb 14m'\n        SELECT regexp_replace('[{}]', '\\}\\]', '\\}'); -- '[{}'\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regexp_replace(string, pattern, function) -> varchar\n\n    Replaces every instance of the substring matched by the regular expression\n    ``pattern`` in ``string`` using ``function``. The lambda expression\n    ``function`` is invoked for each match with the capturing groups passed as an\n    array. Capturing group numbers start at 1; there is no group for the entire match\n    (if you need this, surround the entire expression with parenthesis). ::\n\n        SELECT regexp_replace('new york', '(\\w)(\\w*)', x -> upper(x[1]) || lower(x[2])); --'New York'\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    regexp_split(string, pattern) -> array(varchar):\n\n    Splits ``string`` using the regular expression ``pattern`` and returns an\n    array. Trailing empty strings are preserved::\n\n        SELECT regexp_split('1a 2b 14m', '\\s*[a-z]+\\s*'); -- [1, 2, 14, ]\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(96540);const a={},s=t.createContext(a);function i(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);