"use strict";(self.webpackChunkkumo_website=self.webpackChunkkumo_website||[]).push([[66212],{44401:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var r=t(74848),i=t(28453);const s={},a=void 0,c={id:"pollux/functions/presto/string",title:"string",description:"String Functions",source:"@site/versioned_docs/version-1.1.1/pollux/functions/presto/string.mdx",sourceDirName:"pollux/functions/presto",slug:"/pollux/functions/presto/string",permalink:"/docs/pollux/functions/presto/string",draft:!1,unlisted:!1,tags:[],version:"1.1.1",lastUpdatedBy:"Jeff lothar",lastUpdatedAt:1748143706e3,frontMatter:{},sidebar:"docs",previous:{title:"URL Functions",permalink:"/docs/pollux/functions/presto/url"},next:{title:"Decimal Operators",permalink:"/docs/pollux/functions/presto/decimal"}},o={},l=[{value:"Unicode Functions",id:"unicode-functions",level:2}];function h(n){const e={admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:"String Functions"}),"\n",(0,r.jsxs)(e.admonition,{type:"info",children:[(0,r.jsx)(e.p,{children:"These functions assume that the input strings contain valid UTF-8 encoded\nUnicode code points. There are no explicit checks for valid UTF-8 and\nthe functions may return incorrect results on invalid UTF-8."}),(0,r.jsxs)(e.p,{children:["Additionally, the functions operate on Unicode code points and not user\nvisible ",(0,r.jsx)(e.em,{children:"characters"})," (or ",(0,r.jsx)(e.em,{children:"grapheme clusters"}),").  Some languages combine\nmultiple code points into a single user-perceived ",(0,r.jsx)(e.em,{children:"character"}),", the basic\nunit of a writing system for a language, but the functions will treat each\ncode point as a separate unit."]}),(0,r.jsxs)(e.p,{children:["The :func:",(0,r.jsx)(e.code,{children:"lower"})," and :func:",(0,r.jsx)(e.code,{children:"upper"})," functions do not perform\nlocale-sensitive, context-sensitive, or one-to-many mappings required for\nsome languages. Specifically, this will return incorrect results for\nLithuanian, Turkish and Azeri."]})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    chr(n) -> varchar\n\n    Returns the Unicode code point ``n`` as a single character string.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    codepoint(string) -> integer\n\n    Returns the Unicode code point of the only character of ``string``.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    concat(string1, ..., stringN) -> varchar\n\n    Returns the concatenation of ``string1``, ``string2``, ``...``, ``stringN``.\n    This function provides the same functionality as the\n    SQL-standard concatenation operator (``||``).\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    ends_with(string, substring) -> boolean\n\n    Returns whether ``string`` ends_with with ``substring``.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    from_utf8(binary) -> varchar\n\n    Decodes a UTF-8 encoded string from ``binary``. Invalid UTF-8 sequences\n    are replaced with the Unicode replacement character ``U+FFFD``. Each\n    invalid UTF-8 codepoint, including those of multi-byte long, is replaced\n    with one replacement character.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    from_utf8(binary, replace) -> varchar\n    :noindex:\n\n    Decodes a UTF-8 encoded string from ``binary``. Invalid UTF-8 sequences are\n    replaced with `replace`. Each invalid UTF-8 codepoint, including those of\n    multi-byte long, is replaced with one replacement character. The `replace`\n    argument can be either Unicode code point (bigint), a single character or\n    empty string. When `replace` is an empty string invalid characters are\n    removed.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    hamming_distance(string1, string2) -> bigint\n\n    Returns the Hamming distance of ``string1`` and ``string2``,\n    i.e. the number of positions at which the corresponding characters are different.\n    Note that the two strings must have the same length.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    length(string) -> bigint\n\n    Returns the length of ``string`` in characters.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    levenshtein_distance(string_1, string_2) -> bigint\n\n    Returns the Levenshtein edit distance of 2 strings. I.e. the minimum number of single-character edits\n    (insertions, deletions or substitutions) needed to convert ``string_1`` to ``string_2``.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    lower(string) -> varchar\n\n    Converts ``string`` to lowercase.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    lpad(string, size, padstring) -> varchar\n\n     Left pads ``string`` to ``size`` characters with ``padstring``. If\n     ``size`` is less than the length of ``string``, the result is truncated\n     to ``size`` characters. ``size`` must not be negative and ``padstring``\n     must be non-empty.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    ltrim(string) -> varchar\n\n    Removes leading whitespace from string. See :func:`trim` for the set of\n    recognized whitespace characters.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    ltrim(string, chars) -> varchar\n    :noindex:\n\n    Removes the longest substring containing only characters in ``chars`` from the beginning of the ``string``. ::\n\n        SELECT ltrim('test', 't'); -- est\n        SELECT ltrim('tetris', 'te'); -- ris\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    replaceFirst(string, search, replace) -> varchar\n\n    Removes the first instances of ``search`` with ``replace`` in ``string``.\n\n    If ``search`` is an empty string, inserts ``replace`` in front of ``string``.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    replace(string, search) -> varchar\n\n    Removes all instances of ``search`` from ``string``.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    replace(string, search, replace) -> varchar\n    :noindex:\n\n    Replaces all instances of ``search`` with ``replace`` in ``string``.\n\n    If ``search`` is an empty string, inserts ``replace`` in front of every\n    character and at the end of the ``string``.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    reverse(string) -> varchar\n    :noindex:\n\n    Returns input string with characters in reverse order.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    reverse(varbinary) -> varbinary\n    :noindex:\n\n    Returns input binary with bytes in reversed order.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    rpad(string, size, padstring) -> varchar\n\n     Right pads ``string`` to ``size`` characters with ``padstring``. If\n     ``size`` is less than the length of ``string``, the result is truncated\n     to ``size`` characters. ``size`` must not be negative and ``padstring``\n     must be non-empty.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    rtrim(string) -> varchar\n\n    Removes trailing whitespace from string. See :func:`trim` for the set of\n    recognized whitespace characters.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    rtrim(string, chars) -> varchar\n    :noindex:\n\n    Removes the longest substring containing only characters in ``chars`` from the end of the ``string``. ::\n\n        SELECT rtrim('test', 't'); -- tes\n        SELECT rtrim('test...', '.'); -- test\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    split(string, delimiter) -> array(string)\n\n    Splits ``string`` on ``delimiter`` and returns an array.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    split(string, delimiter, limit) -> array(string)\n    :noindex:\n\n    Splits ``string`` on ``delimiter`` and returns an array of size at most ``limit``.\n\n    The last element in the array always contains everything left in the string.\n    ``limit`` must be a positive number.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    split_part(string, delimiter, index) -> string\n\n    Splits ``string`` on ``delimiter`` and returns the part at index ``index``.\n\n    Field indexes start with 1. If the index is larger than the number of fields,\n    then null is returned.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    split_to_map(string, entryDelimiter, keyValueDelimiter) -> map<varchar, varchar>\n\n    Splits ``string`` by ``entryDelimiter`` and ``keyValueDelimiter`` and returns a map.\n    ``entryDelimiter`` splits ``string`` into key-value pairs. ``keyValueDelimiter`` splits\n    each pair into key and value. Note that ``entryDelimiter`` and ``keyValueDelimiter`` are\n    interpreted literally, i.e., as full string matches.\n\n    ``entryDelimiter`` and ``keyValueDelimiter`` must not be empty and must not be the same.\n    ``entryDelimiter`` is allowed to be the trailing character.\n\n    Raises an error if there are duplicate keys.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:'    split_to_map(string, entryDelimiter, keyValueDelimiter, function(K,V1,V2,R)) -> map<varchar, varchar>\n\n    Splits ``string`` by ``entryDelimiter`` and ``keyValueDelimiter`` and returns a map.\n    ``entryDelimiter`` splits ``string`` into key-value pairs. ``keyValueDelimiter`` splits\n    each pair into key and value. Note that ``entryDelimiter`` and ``keyValueDelimiter`` are\n    interpreted literally, i.e., as full string matches.\n\n    ``function(K,V1,V2,R)`` is used to decide whether to keep first or last value for\n    duplicate keys. (k, v1, v2) -> v1 keeps first value. (k, v1, v2) -> v2 keeps last\n    value. Arbitrary functions are not supported. ::\n\n        SELECT(split_to_map(\'a:1;b:2;a:3\', \';\', \':\', (k, v1, v2) -> v1)); -- {"a": "1", "b": "2"}\n        SELECT(split_to_map(\'a:1;b:2;a:3\', \';\', \':\', (k, v1, v2) -> v2)); -- {"a": "3", "b": "2"}\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    split_to_multimap(string, entryDelimiter, keyValueDelimiter) -> map<varchar, array<varchar>>\n\n    Splits ``string`` by ``entryDelimiter`` and ``keyValueDelimiter`` and returns a map containing an array of values for each unique key.\n    ``entryDelimiter`` splits ``string`` into key-value pairs. ``keyValueDelimiter`` splits each pair into key and value.\n    The values for each key will be in the same order as they appeared in ``string``.\n\n    Note that ``entryDelimiter`` and ``keyValueDelimiter`` are interpreted literally, i.e., as full string matches.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    starts_with(string, substring) -> boolean\n\n    Returns whether ``string`` starts with ``substring``.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    strpos(string, substring) -> bigint\n\n    Returns the starting position of the first instance of ``substring`` in\n    ``string``. Positions start with ``1``. If not found, ``0`` is returned.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    strpos(string, substring, instance) -> bigint\n    :noindex:\n\n    Returns the position of the N-th ``instance`` of ``substring`` in ``string``.\n    ``instance`` must be a positive number.\n    Positions start with ``1``. If not found, ``0`` is returned.\n    It takes into account overlapping strings when counting occurrences. ::\n\n        SELECT strpos('aaa', 'aa', 2); -- 2\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    strrpos(string, substring) -> bigint\n\n    Returns the starting position of the last instance of ``substring`` in\n    ``string``. Positions start with ``1``. If not found, ``0`` is returned.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    strrpos(string, substring, instance) -> bigint\n    :noindex:\n\n    Returns the position of the N-th ``instance`` of ``substring`` in ``string`` starting from the end of the string.\n    ``instance`` must be a positive number.\n    Positions start with ``1``. If not found, ``0`` is returned.\n    It takes into account overlapping strings when counting occurrences. ::\n\n        SELECT strrpos('aaa', 'aa', 2); -- 1\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    trail(string, N) -> varchar\n\n    Returns the last ``N`` characters of the input ``string`` up to at most the length of ``string``.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    substr(string, start) -> varchar\n\n    Returns the rest of ``string`` from the starting position ``start``.\n    Positions start with ``1``. A negative starting position is interpreted\n    as being relative to the end of the string. Returns empty string if absolute\n    value of ``start`` is greater then length of the ``string``.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    substr(string, start, length) -> varchar\n    :noindex:\n\n    Returns a substring from ``string`` of length ``length`` from the starting\n    position ``start``. Positions start with ``1``. A negative starting\n    position is interpreted as being relative to the end of the string.\n    Returns empty string if absolute value of ``'start`` is greater then\n    length of the ``string``.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    trim(string) -> varchar\n\n    Removes starting and ending whitespaces from ``string``.\n\n    Recognized whitespace characters:\n\n    ======  =========================== ======  ===========================\n    Code    Description                 Code    Description\n    ======  =========================== ======  ===========================\n    9       TAB (horizontal tab)        U+1680  Ogham Space Mark\n    10      LF (NL line feed, new line) U+2000  En Quad\n    11      VT (vertical tab)           U+2001  Em Quad\n    12      FF (NP form feed, new page) U+2002  En Space\n    13      CR (carriage return)        U+2003  Em Space\n    28      FS (file separator)         U+2004  Three-Per-Em Space\n    29      GS (group separator)        U+2005  Four-Per-Em Space\n    30      RS (record separator)       U+2006  Four-Per-Em Space\n    31      US (unit separator)         U+2008  Punctuation Space\n    32      Space                       U+2009  Thin Space\n    _       _                           U+200a  Hair Space\n    _       _                           U+200a  Hair Space\n    _       _                           U+2028  Line Separator\n    _       _                           U+2029  Paragraph Separator\n    _       _                           U+205f  Medium Mathematical Space\n    _       _                           U+3000  Ideographic Space\n    ======  =========================== ======  ===========================\n\n```cpp\n    trim(string, chars) -> varchar\n    :noindex:\n\n    Removes the longest substring containing only characters in ``chars`` from the beginning and end of the ``string``. ::\n\n        SELECT trim('test', 't'); -- es\n        SELECT trim('.t.e.s.t.', '.t'); -- e.s\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    upper(string) -> varchar\n\n    Converts ``string`` to uppercase.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    word_stem(word) -> varchar\n\n    Returns the stem of ``word`` in the English language. If the ``word`` is not an English word,\n    the ``word`` in lowercase is returned.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    word_stem(word, lang) -> varchar\n\n    Returns the stem of ``word`` in the ``lang`` language. This function supports the following languages:\n\n    =========== ================\n    lang        Language\n    =========== ================\n    ``ca``      ``Catalan``\n    ``da``      ``Danish``\n    ``de``      ``German``\n    ``en``      ``English``\n    ``es``      ``Spanish``\n    ``eu``      ``Basque``\n    ``fi``      ``Finnish``\n    ``fr``      ``French``\n    ``hu``      ``Hungarian``\n    ``hy``      ``Armenian``\n    ``ir``      ``Irish``\n    ``it``      ``Italian``\n    ``lt``      ``Lithuanian``\n    ``nl``      ``Dutch``\n    ``no``      ``Norwegian``\n    ``pt``      ``Portuguese``\n    ``ro``      ``Romanian``\n    ``ru``      ``Russian``\n    ``sv``      ``Swedish``\n    ``tr``      ``Turkish``\n    =========== ================\n\n    If the specified ``lang`` is not supported, this function throws a user error.\n"})}),"\n",(0,r.jsx)(e.h2,{id:"unicode-functions",children:"Unicode Functions"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    normalize(string) -> varchar\n\n    Transforms ``string`` with NFC normalization form.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    normalize(string, form) -> varchar\n\n    Reference: https://unicode.org/reports/tr15/#Norm_Forms\n    Transforms ``string`` with the specified normalization form.\n    ``form`` must be be one of the following keywords:\n\n    ======== ===========\n    Form     Description\n    ======== ===========\n    ``NFD``  Canonical Decomposition\n    ``NFC``  Canonical Decomposition, followed by Canonical Composition\n    ``NFKD`` Compatibility Decomposition\n    ``NFKC`` Compatibility Decomposition, followed by Canonical Composition\n    ======== ===========\n\n    .. note::\n\n        This SQL-standard function has special syntax and requires\n        specifying ``form`` as a keyword, not as a string.\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"    to_utf8(string) -> varbinary\n\n    Encodes ``string`` into a UTF-8 varbinary representation.\n"})})]})}function p(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(h,{...n})}):h(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>c});var r=t(96540);const i={},s=r.createContext(i);function a(n){const e=r.useContext(s);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);