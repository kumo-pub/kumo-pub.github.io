"use strict";(self.webpackChunkkumo_website=self.webpackChunkkumo_website||[]).push([[83338],{30674:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var o=t(74848),r=t(28453);const s={},i="HyperLogLog Functions",a={id:"pollux/functions/presto/hyperloglog",title:"HyperLogLog Functions",description:"Pollux implements the Presto'sapprox_distinct function using the",source:"@site/versioned_docs/version-1.1.1/pollux/functions/presto/hyperloglog.mdx",sourceDirName:"pollux/functions/presto",slug:"/pollux/functions/presto/hyperloglog",permalink:"/docs/pollux/functions/presto/hyperloglog",draft:!1,unlisted:!1,tags:[],version:"1.1.1",lastUpdatedBy:"Jeff lothar",lastUpdatedAt:1748143706e3,frontMatter:{},sidebar:"docs",previous:{title:"IP Functions",permalink:"/docs/pollux/functions/presto/ipaddress"},next:{title:"Geospatial Operators",permalink:"/docs/pollux/functions/presto/geospatial"}},l={},c=[{value:"Data Structures",id:"data-structures",level:2},{value:"Serialization",id:"serialization",level:2},{value:"Functions",id:"functions",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"hyperloglog-functions",children:"HyperLogLog Functions"})}),"\n",(0,o.jsxs)(n.p,{children:["Pollux implements the Presto's :func:",(0,o.jsx)(n.code,{children:"approx_distinct"})," function using the\n",(0,o.jsx)(n.code,{children:"HyperLogLog <https://en.wikipedia.org/wiki/HyperLogLog>"}),"_ data structure."]}),"\n",(0,o.jsx)(n.h2,{id:"data-structures",children:"Data Structures"}),"\n",(0,o.jsxs)(n.p,{children:["Like Presto, Pollux implements HyperLogLog data sketches as a set of 32-bit\nbuckets which store a ",(0,o.jsx)(n.em,{children:"maximum hash"}),". They can be stored sparsely (as a map\nfrom bucket ID to bucket), or densely (as a contiguous memory block). The\nHyperLogLog data structure starts as the sparse representation, switching to\ndense when it is more efficient."]}),"\n",(0,o.jsx)(n.h2,{id:"serialization",children:"Serialization"}),"\n",(0,o.jsxs)(n.p,{children:["Data sketches can be serialized to and deserialized from ",(0,o.jsx)(n.code,{children:"varbinary"}),". This\nallows them to be stored for later use.  Combined with the ability to merge\nmultiple sketches, this allows one to calculate :func:",(0,o.jsx)(n.code,{children:"approx_distinct"})," of the\nelements of a partition of a query, then for the entirety of a query with very\nlittle cost."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, calculating the ",(0,o.jsx)(n.code,{children:"HyperLogLog"})," for daily unique users will allow\nweekly or monthly unique users to be calculated incrementally by combining the\ndailies. This is similar to computing weekly revenue by summing daily revenue."]}),"\n",(0,o.jsx)(n.p,{children:"Serialization format is compatible (actually, identical) to Presto's."}),"\n",(0,o.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"    approx_set(x) -> HyperLogLog\n\n    Returns the ``HyperLogLog`` sketch of the input data set of ``x``.\n    The value of the maximum standard error is defaulted to ``0.01625``.\n    This data sketch underlies :func:`approx_distinct` and can be stored and\n    used later by calling ``cardinality()``.\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"    approx_set(x, e) -> HyperLogLog\n   :noindex:\n\n    Returns the ``HyperLogLog`` sketch of the input data set of ``x``, with\n    a maximum standard error of ``e``. The current implementation of this\n    function requires that ``e`` be in the range of ``[0.0040625, 0.26000]``.\n    This data sketch underlies :func:`approx_distinct` and can be stored and\n    used later by calling ``cardinality()``.\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"    cardinality(hll) -> bigint\n    :noindex:\n\n    This will perform :func:`approx_distinct` on the data summarized by the\n    ``hll`` HyperLogLog data sketch.\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"    empty_approx_set() -> HyperLogLog\n\n    Returns an empty ``HyperLogLog``.\n    The value of the maximum standard error is defaulted to ``0.01625``.\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"    empty_approx_set(e) -> HyperLogLog\n   :noindex:\n\n    Returns an empty ``HyperLogLog`` with a maximum standard error of ``e``.\n    The current implementation of this function requires that ``e`` be in\n    the range of ``[0.0040625, 0.26000]``.\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"    merge(HyperLogLog) -> HyperLogLog\n\n    Returns the ``HyperLogLog`` of the aggregate union of the individual ``hll``\n    HyperLogLog structures.\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(96540);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);